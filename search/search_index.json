{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dino Dino is a distributed notification service intended to push events to groups of clients. Example use cases are chat server, real-time notifications for websites, push notifications for mobile apps, multi-player browser games, and more. Dino is un-opinionated and any kind of events can be sent, meaning Dino only acts as the router of events between clients. Any number of nodes can be started on different machines or same machine on different port. Flask will handle connection routing using either Redis or RabbitMQ as a message queue internally. An nginx reverse proxy needs to sit in-front of all these nodes with sticky sessions ( ip_hash ). Fail-over can be configured in nginx for high availability.","title":"Home"},{"location":"#dino","text":"Dino is a distributed notification service intended to push events to groups of clients. Example use cases are chat server, real-time notifications for websites, push notifications for mobile apps, multi-player browser games, and more. Dino is un-opinionated and any kind of events can be sent, meaning Dino only acts as the router of events between clients. Any number of nodes can be started on different machines or same machine on different port. Flask will handle connection routing using either Redis or RabbitMQ as a message queue internally. An nginx reverse proxy needs to sit in-front of all these nodes with sticky sessions ( ip_hash ). Fail-over can be configured in nginx for high availability.","title":"Dino"},{"location":"md/acl/","text":"Access Control Lists Available acl_type s age gender membership group country city image has_webcam fake_checked owner admin room_owner moderator superuser crossroom samechannel sameroom disallow custom For custom, see Custom ACL Pattern below. Available actions For rooms, the actions are: join setacl history create list kick message crossroom ban autojoin And for channels: create setacl list create message crossroom ban whisper Custom ACL Pattern A custom ACL pattern may be set instead of the regular simple ACL types. A simple grammar exists to specify this. Grammar | OR , AND ! NOT = VALUE () GROUP AND has preference over OR, GROUP can be used to combine grammars, Nested parentheses are NOT allowed. Since AND has preference over OR, two or more OR clauses can be grouped using parentheses so avoid an AND clause taking over, same as with boolean logic: a: true b: false c: true a & b | c => false age=35,gender=f|membership=normal b & (b | c) => true age=35,(gender=f|membership=normal) Examples Either the user is 35 years or older, OR the user is a female and less than (or equal to) 26 years old: age=35:|gender=f,age:26 Parenthesis may be used to group or clauses before and clauses (since AND has priority before OR), as in this example, if the user is a female or above the age of 35 (inclusive) he/she will be allowed to join, as long as he/she ALSO is NOT a normal account. (age=35:|gender=f),membership=!normal Compare with the same without parenthesis, where the AND would take priority over the OR; as long as the user is above 35 (inclusive) he/she'll be allowed to join. If less than 35, he/she can still join if BOTH female and NOT normal account. age=35:|gender=f,membership=!normal For some channels, maybe females should not be allowed to list the rooms, unless they have the paying membership type. In this case we can negate the values to allow everything except the specified one. Everyone else can list and join: gender=!f|gender=f,membership=paying","title":"ACL"},{"location":"md/acl/#access-control-lists","text":"","title":"Access Control Lists"},{"location":"md/acl/#available-acl_types","text":"age gender membership group country city image has_webcam fake_checked owner admin room_owner moderator superuser crossroom samechannel sameroom disallow custom For custom, see Custom ACL Pattern below.","title":"Available acl_types"},{"location":"md/acl/#available-actions","text":"For rooms, the actions are: join setacl history create list kick message crossroom ban autojoin And for channels: create setacl list create message crossroom ban whisper","title":"Available actions"},{"location":"md/acl/#custom-acl-pattern","text":"A custom ACL pattern may be set instead of the regular simple ACL types. A simple grammar exists to specify this.","title":"Custom ACL Pattern"},{"location":"md/acl/#grammar","text":"| OR , AND ! NOT = VALUE () GROUP AND has preference over OR, GROUP can be used to combine grammars, Nested parentheses are NOT allowed. Since AND has preference over OR, two or more OR clauses can be grouped using parentheses so avoid an AND clause taking over, same as with boolean logic: a: true b: false c: true a & b | c => false age=35,gender=f|membership=normal b & (b | c) => true age=35,(gender=f|membership=normal)","title":"Grammar"},{"location":"md/acl/#examples","text":"Either the user is 35 years or older, OR the user is a female and less than (or equal to) 26 years old: age=35:|gender=f,age:26 Parenthesis may be used to group or clauses before and clauses (since AND has priority before OR), as in this example, if the user is a female or above the age of 35 (inclusive) he/she will be allowed to join, as long as he/she ALSO is NOT a normal account. (age=35:|gender=f),membership=!normal Compare with the same without parenthesis, where the AND would take priority over the OR; as long as the user is above 35 (inclusive) he/she'll be allowed to join. If less than 35, he/she can still join if BOTH female and NOT normal account. age=35:|gender=f,membership=!normal For some channels, maybe females should not be allowed to list the rooms, unless they have the paying membership type. In this case we can negate the values to allow everything except the specified one. Everyone else can list and join: gender=!f|gender=f,membership=paying","title":"Examples"},{"location":"md/api/","text":"Error Codes OK = 200 UNKNOWN_ERROR = 250 MISSING_ACTOR_ID = 500 MISSING_OBJECT_ID = 501 MISSING_TARGET_ID = 502 MISSING_OBJECT_URL = 503 MISSING_TARGET_DISPLAY_NAME = 504 MISSING_ACTOR_URL = 505 MISSING_OBJECT_CONTENT = 506 MISSING_OBJECT = 507 MISSING_OBJECT_ATTACHMENTS = 508 MISSING_ATTACHMENT_TYPE = 509 MISSING_ATTACHMENT_CONTENT = 510 INVALID_TARGET_TYPE = 600 INVALID_ACL_TYPE = 601 INVALID_ACL_ACTION = 602 INVALID_ACL_VALUE = 603 INVALID_STATUS = 604 INVALID_OBJECT_TYPE = 605 INVALID_BAN_DURATION = 606 EMPTY_MESSAGE = 700 NOT_BASE64 = 701 USER_NOT_IN_ROOM = 702 USER_IS_BANNED = 703 ROOM_ALREADY_EXISTS = 704 NOT_ALLOWED = 705 VALIDATION_ERROR = 706 ROOM_FULL = 707 NOT_ONLINE = 708 TOO_MANY_PRIVATE_ROOMS = 709 ROOM_NAME_TOO_LONG = 710 ROOM_NAME_TOO_SHORT = 711 INVALID_TOKEN = 712 INVALID_LOGIN = 713 MSG_TOO_LONG = 714 MULTIPLE_ROOMS_WITH_NAME = 715 TOO_MANY_ATTACHMENTS = 716 NOT_ENABLED = 717 ROOM_NAME_RESTRICTED = 718 NOT_ALLOWED_TO_WHISPER_USER = 719 NOT_ALLOWED_TO_WHISPER_CHANNEL = 720 NO_SUCH_USER = 800 NO_SUCH_CHANNEL = 801 NO_SUCH_ROOM = 802 NO_ADMIN_ROOM_FOUND = 803 NO_USER_IN_SESSION = 804 NO_ADMIN_ONLINE = 805 connect Responds with event name gn_connect . Request contains no data. Response data if successful: { \"status_code\": 200 } login Responds with event name gn_login . Request contains: { \"verb\": \"login\", \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<user name>\", \"attachments\": [ { \"objectType\": \"token\", \"content\": \"<user token>\" } ] } } Response data if successful: { \"status_code\": 200, \"data\": { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user id>\", \"displayName\": \"<user name in base64>\", \"attachments\": [ { \"objectType\": \"room_role\", \"id\": \"<room UUID>\", \"content\": \"moderator,owner\" }, { \"objectType\": \"room_role\", \"id\": \"<room UUID>\", \"content\": \"owner\" }, { \"objectType\": \"channel_role\", \"id\": \"<channel UUID>\", \"content\": \"admin,owner\" }, { \"objectType\": \"global_roles\", \"content\": \"superuser,globalmod\" } ] }, \"object\": { \"objectType\": \"history\", \"attachments\": [{ \"author\": { \"id\": \"<sender id>\", \"displayName\": \"<sender name in base64>\" }, \"content\": \"<message in base64>\", \"id\": \"84421980-d84a-4f6f-9ad7-0357d15d99f8\", \"published\": \"2017-11-17T07:19:12Z\", \"summary\": \"9fa5b40a-f0a6-44ea-93c1-acf2947e5f09\", \"objectType\": \"history\" }] }, \"verb\": \"login\" } } The object attachments are non-acked messages sent to any private room s (i.e. conversation based private messaging). The object.attachments[0].id is the message UUID, while the object.attachments[0].summary is the room UUID. Multiple attachments will be listed if more than one un-acked message was found during login. For the user roles, there will be an ID on the attached object if the role is for a channel or for a room. If it's a global role there will be no ID on the object. Roles are comma separated if more than one role for a room/channel/global. Possible roles are: global superuser (globalmod) channel owner (owner) channel admin (admin) room owner (owner) room moderator (moderator) The only difference between global moderator and super user is that the global moderators can't remove static rooms (ephemeral set to false in room list). Invisible login See Invisibility docs. list_channels Responds with event name gn_list_channels . Request contains: { \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"channels\", \"attachments\": [ { \"id\": \"<channel UUID>\", \"displayName\": \"<channel name>\", \"url\": 8, \"content\": \"normal,another-tag\", \"objectType\": \"static\", \"attachments\": [ { \"summary\": \"message\", \"objectType\": \"membership\", \"content\": \"1\" } ] }, { \"id\": \"<channel UUID>\", \"displayName\": \"<channel name>\", \"url\": 20, \"content\": \"another-tag\", \"objectType\": \"temporary\", \"attachments\": [ { \"summary\": \"join\", \"objectType\": \"gender\", \"content\": \"f\" } ] } ] }, \"verb\": \"list\" } } Each channel has a url field, which is the sort order defined in the admin interface, in ascending order (lower url means higher up in the list). The objectType of a channel tells you if this channel only contains static rooms, only temporary rooms or a mix of both. Possible values are thus: temporary static mix If the channel has 0 rooms in it, the objectType will be mix . The content field on each attachment specifies a comma separated list of tags for the channel. Attachments for each channel describes the ACLs for that channel. received Acknowledge that one or more messages has been received. The status will change from sent to delivered . Does not emit a response, only invokes the callback with the status_code and potentially and error_message . Note that if multiple messages are being acknowledged at the same time, they all have to be for the same room ( target.id ). Request contains: { \"verb\": \"receive\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } } msg_status Check ack status of a set of messages sent to a single user. Request: { \"verb\": \"check\", \"target\": { \"id\": \"<uuid of the user to check ack status for>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } } If message guarantee is not enabled on the server the 717 ( NOT_ENABLED ) error code will be retured as part of the callback, and no gn_msg_status event will be sent back. Response will be sent as the gn_msg_status event with the following content: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"statuses\", \"attachments\": [ { \"id\": \"<msg UUID 1>\", \"content\": \"<ack status 1>\" }, { \"id\": \"<msg UUID 2>\", \"content\": \"<ack status 2>\" }, { \"id\": \"<msg UUID 3>\", \"content\": \"<ack status 3>\" } ] }, \"target\": { \"id\": \"<user ID the ack status are for>\" }, \"verb\": \"check\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } } The ack statuses are: 0: not acknowledged (receiver has not acked it yet) 1: received 2: read read Acknowledge that one or more messages has been read. The status will change from sent / delivered to read . Does not emit a response, only invokes the callback with the status_code and potentially and error_message . Note that if multiple messages are being acknowledged at the same time, they all have to be for the same room ( target.id ). Request contains: { \"verb\": \"read\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } } If the target.id is specified, the request will be relayed to online users in that room. E.g., user A sends message X to the room, user B then sends a read event after receiving it; this read event will then be sent to user A with the event name gn_message_read . list_rooms Get a list of all rooms for a channel. Responds with event name gn_list_rooms . Request contains: { \"object\": { \"url\": \"<channel UUID>\" }, \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"rooms\", \"url\": \"<channel UUID>\", \"attachments\": [ { \"id\": \"<room UUID>\", \"displayName\": \"<room name>\", \"url\": 8, \"summary\": <number of users in this room (integer)>, \"objectType\": \"static\", \"content\": \"moderator,owner\", \"attachments\": [ { \"summary\": \"join\", \"objectType\": \"gender\", \"content\": \"f\" } ] }, { \"id\": \"<room UUID>\", \"displayName\": \"<room name>\", \"url\": 20, \"summary\": <number of users in this room (integer)>, \"objectType\": \"temporary\", \"content\": \"\", \"attachments\": [ { \"summary\": \"join\", \"objectType\": \"gender\", \"content\": \"f\" } ] } ] }, \"verb\": \"list\" } } The url field for object is the UUID of the channel that these rooms are for. Each room has a url field, which is the sort order defined in the admin interface, in ascending order (lower url means higher up in the list). The content field on the attachments describe what kind of role you have for that room. If no roles are set then content will be empty, otherwise it will be a comma separated list of roles. Possible roles for rooms are: moderator owner globalmod superuser Global roles and roles for channels are returned in the gn_login event. Attachments for each room describes the ACLs for that room. The objectType for each room describes if the room is static or temporary. Static rooms are not removed automatically when empty, while temporary rooms are removed when the owner leaves (usually only for user created rooms). update_user_info If a user e.g. changes his/her avatar, the change can be broadcasted to users in the same rooms as this user is in. To e.g. let other users know this user is currently streaming video, the objectType is_streaming might be used: { \"object\": { \"attachments\": [ { \"content\": \"MA==\", \"objectType\": \"is_streaming\" } ], \"objectType\": \"userInfo\" }, \"verb\": \"update\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } The content of the attachments needs to be base64 encoded. Updates are saved in redis and thus will be included in the user info returned in gn_join and gn_users_in_room . Responds with event name gn_update_user_info . When the update is sent to other users it will be received as an event with name gn_user_info_updated . Response data if successful: { \"status_code\": 200 } Or if missing data, e.g.: { \"status_code\": 509, \"message\": \"no objectType on attachment for object\" } request_admin When help is wanted in a room, a user can request for an admin to join and help out. Every channel has an Admin room, which only admins can see when listing rooms and only admins can join. When a request_admin event is sent to the server it will be delivered to the admin room for that channel and the admins in that room can decide what to do. Important: If no user with the global role superuser or globalmod is online, the 805 code will be returned (\"no admin is online\"). Responds with event name gn_request_admin . Request contains: { \"target\": { \"id\": \"<room UUID to request help for>\" }, \"object\": { \"content\": \"<base64 encoded message that will be delivered to the admin room>\" }, \"verb\": \"help\" } Response data if successful: { \"status_code\": 200 } If no admin is online, the response will be: { \"status_code\": 805, \"message\": \"no admin is online\" } The object.content could be anything, e.g. a base64 encoded json message with link to backend, extra information, a reason text etc. The event generated to be sent to the admin room is called gn_admin_requested (see Events for more information). leave Leave a room. Responds with event name gn_leave . Request contains: { \"target\": { \"id\": \"<room UUID>\" }, \"verb\": \"leave\" } Or, if you want to leave a room based on the room name: { \"verb\": \"join\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } Response data if successful: { \"status_code\": 200 } users_in_room List all users in a room. Responds with event name gn_users_in_room . Request contains: { \"target\": { \"id\": \"<room UUID>\" }, \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"users\", \"attachments\": [ { \"id\": \"<user UUID>\", \"displayName\": \"<user name>\", \"content\": \"globalmod,moderator\" \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, { \"id\": \"<user UUID>\", \"displayName\": \"<user name>\", \"content\": \"moderator\" \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] } ] }, \"verb\": \"list\" } } The content of the user attachment describes the roles this user has in this room, plus any global roles. Examples: globalmod,moderator moderator superuser If no specific roles, the value will be blank. history TODO: include user UUID as well as user name. When joining a room the history will be included in the gn_join response event. If history is needed for a separate reason than the history event can be used. Can also be used to get history for a private chat with another user, if \"target.id\" is set to the user UUID instead of the room UUID. Responds with event name gn_history . Request contains: { \"target\": { \"id\": \"<room UUID>\" }, \"updated\": \"<last read timestamp, if configured in server will return messages since this time>\", \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"messages\", \"attachments\": [ { \"author\": { \"id\": \"<the user id of the sender>\", \"displayName\": \"<the user name of the sender>\" }, \"id\": \"<message ID>\", \"content\": \"<the message content>\", \"published\": \"<the time it was sent, RFC3339>\" }, { \"author\": { \"id\": \"<the user id of the sender>\", \"displayName\": \"<the user name of the sender>\" }, \"id\": \"<message ID>\", \"content\": \"<the message content>\", \"published\": \"<the time it was sent, RFC3339>\" } ] }, \"target\": { \"id\": \"<room UUID>\" }, \"verb\": \"history\" } } status Change the online status for this user. Responds with gn_status . Request contains: { \"verb\": \"<one of online/offline/invisible>\" } Response data if successful: { \"status_code\": 200 } get_acl Get the permissions (ACL) for a channel or room. Responds with gn_get_acl . Request contains: { \"target\": { \"id\": \"<room UUID>\", \"objectType\": \"<room/channel>\" }, \"verb\": \"get\" } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<room/channel UUID>\", \"objectType\": \"<room/channel>\" }, \"object\": { \"objectType\": \"acl\", \"attachments\": [ { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" }, { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" } ] }, \"verb\": \"get\" } } set_acl Update the permissions of a room/channel. If the \"content\" is blank, the ACL with that type for the specified action will be removed. Example \"API actions\" are \"join\", \"create\", \"message\", \"kick\". Example \"permission types\" are \"age\", \"gender\", \"membership\". Responds with gn_set_acl . Request contains: { \"target\": { \"id\": \"<room/channel UUID>\", \"objectType\": \"<room/channel>\" }, \"object\": { \"objectType\": \"acl\", \"attachments\": [ { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" }, { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" } ] }, \"verb\": \"set\" } Response data if successful: { \"status_code\": 200 } create Create a new room under a channel. The sender of the event will be set as the first owner of the new room. Responds with gn_create . Request contains: { \"target\": { \"displayName\": \"<name of the new room>\" }, \"object\": { \"url\": \"<channel UUID>\" }, \"verb\": \"create\" } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<the generated UUID for this room>\", \"displayName\": \"<name of the new room>\", \"objectType\": \"temporary\" }, \"object\": { \"url\": \"<channel UUID>\" }, \"verb\": \"create\" } } If the amount of private rooms already exceed 2, the error code 709 ( TOO_MANY_PRIVATE_ROOMS ) will be returned. The target.objectType will always be temporary since all rooms created using the API are user created rooms, meaning they will be automatically removed when the owner leaves. It is also possible to specify ACLs for a room while creating it, but adding object.attachments as in the set_acl event: { \"target\": { \"displayName\": \"<name of the new room>\" }, \"object\": { \"url\": \"<channel UUID>\", \"objectType\": \"acl\", \"attachments\": [ { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" }, { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" } ] }, \"verb\": \"create\" } invite Invite another user to a room the current user is already in. Responds with gn_invite . Request contains: { \"target\": { \"id\": \"<UUID of the user to invite>\" }, \"actor\": { \"url\": \"<the room UUID the invitation is for>\" }, \"verb\": \"invite\" } Response data if successful: { \"status_code\": 200 } delete Delete a message from a room (needs to be superuser, admin for channel, owner of channel, moderator of the room, owner of room or (configurable) sender of the message). If object_type is set to room the object.id should be the UUID of a room. All messages in that room will then be deleted. If object_type is set to anything else, or not specified at all, then object.id is assumed to be the UUID of a single message. Responds with gn_delete . Request contains: { \"target\": { \"id\": \"<UUID of the room to delete from>\" }, \"object\": { \"id\": \"<UUID of the message to delete OR the UUID of the room to clear>\", \"object_type\": \"<optional; if set to 'room' the object.id is assumed to be the room id>\" }, \"verb\": \"delete\" } kick Kick a user from a room. Responds with gn_kick . Request contains: { \"actor\": { \"id\": \"<ID of the user who's kicking someone, leave black for admin ID>\" }, \"target\": { \"id\": \"<ID of the room to kick from>\" }, \"object\": { \"id\": \"<ID of the user to kick>\", \"content\": \"<optional reason field>\" }, \"verb\": \"kick\" } Response data if successful: { \"status_code\": 200 } ban Ban a user from a room for a given amount of time. Responds with gn_ban . Request contains: { \"actor\": { \"id\": \"<ID of the user who's banning someone; leave empty for admin ID>\" }, \"target\": { \"id\": \"<UUID of the room/channel to ban from>\", \"objectType\": \"<room/channel/global>\" }, \"object\": { \"id\": \"<UUID of the user to ban>\", \"summary\": \"<ban duration, an integer suffixed with one of [d, h, m, s]>\", \"content\": \"<optional reason field, base64>\" }, \"verb\": \"ban\" } If banning a used in a room, set objectType to room and target.id to the uuid of the room. If banning from a channel, set objectType to channel and target.id to the uuid of the channel. If banning globally, set objectType to global and skip target.id . Summary is the duration of the ban. It's a number with a suffix d, h, m or s, meaning days, hours, minutes and seconds. Only one suffix can be used. E.g.: 5m (ban for five minutes), 3600s (ban for 3600 seconds, same as 1h), 365d (ban for one year). It's not possible to permanently ban a user, but you can set a very large duration for the same effect. The only restriction is that the date when the ban ends ( utcnow()+duration ) must be before the year 10000 (date lib restriction). Response data if successful: { \"status_code\": 200 } message Send a message to a room UUID (can be the user UUID or an actual room UUID). Responds with event name gn_message . Request contains: { \"verb\": \"send\", \"target\": { \"id\": \"<room uuid>\", \"objectType\": \"<room/private>\" }, \"object\": { \"content\": \"<the message, base64 encoded>\", } } If request is for conversation-based private messaging, use objectType: 'private' . In this case, the other user(s) in this conversation ( owner s of the room ) will initially have a NOT_ACKED status for the message. If they are online they will receive it and they can acknowledge the message. If they are offline they will receive it in gn_login then they come online (all non-acked messages for rooms they are owner for). Response data if successful: { \"status_code\": 200, \"data\": { \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"actor\": { \"id\": \"<your user ID>\", \"displayName\": \"<your user name>\" }, \"verb\": \"send\", \"target\": { \"id\": \"<room ID>\", \"displayName\": \"<room name>\" }, \"object\": { \"content\": \"<the message>\", \"displayName\": \"<the channel name>\", \"url\": \"<the channel id>\", \"objectType\": \"<room/private>\" } } } The response will send the same ActivityStreams as was in the request, with the addition of a server generated ID (uuid) and the published field set to the time the server received the request (in RFC3339 format). remove_room Response with the event name gn_remove_room . Request contains: { \"verb\": \"remove\", \"target\": { \"id\": \"<room ID>\" } } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<room name in base64>\", \"objectType\": \"room\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"removed\" } } report No response. Request contains: { \"verb\": \"report\", \"object\": { \"id\": \"<uuid of message>\", \"content\": \"<the actual message to report, base64>\", \"summary\": \"<optional reason text, base64>\" }, \"target\": { \"id\": \"<user ID to report>\" } } A report will be sent to both the admin room and as an external event published on the MQ. join Responds with the event name gn_join . In the user attachments, the content fields tells you the room roles that the user has in this room (as a comma separated value), plus any global roles. Possible roles are: superuser, globalmod, owner, moderator, admin. Currently only the superuser and globalmod role is considered when the request_admin api is used. Request contains: { \"verb\": \"join\", \"target\": { \"id\": \"<room ID>\" } } Or, if you want to join a room based on the room name: { \"verb\": \"join\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"room\", \"attachments\": [{ \"objectType\": \"acl\", \"attachments\": [] }, { \"objectType\": \"history\", \"attachments\": [{ \"author\": { \"id\": \"50327\", \"displayName\": \"Zmbw==\", \"attachments\": [{ \"objectType\": \"avatar\", \"content\": \"aHR0cDovLzAuYmlsZC5wb3BwZW4ubGFiL20QzdCOUI5XzMwMF9zcS5qcGc=\" }, { \"objectType\": \"app_avatar\", \"content\": \"aHR0cDovLzAuaW1nLnBvcGNvcm4NTAwNDMyNy1GOUI4RjBDNjBBlCOV8zMDBfc3EuanBn\" }, { \"objectType\": \"app_avatar_safe\", \"content\": \"aHR0cDovLzAuaW1nLnBvcGNvcTAwNDMyNy1GOUI4RjBDN3QjlCOV8zMDBfc3EuanBn\" }] }, \"summary\": \"7935a673-da64-4419-818b-e6e0d1864b61\", \"id\": \"d02598a1-6ae6-4182-8f2c-c2e66d941303\", \"content\": \"eyJjb2xvciI6IjiwiZ2nRlOiJkc2EifQ==\", \"published\": \"2019-07-04T07:45:59Z\" }] }, { \"objectType\": \"owner\", \"attachments\": [{ \"id\": \"0\", \"displayName\": \"QWW4=\" }] }, { \"objectType\": \"user\", \"attachments\": [{ \"id\": \"5048\", \"displayName\": \"am8yaw==\", \"attachments\": [{ \"objectType\": \"region\", \"content\": \"Qmlu\" }, { \"objectType\": \"avatar\", \"content\": \"aHR0cDovLzAuYmOTgxRjhBNUM0NDA5MDQ2MDA4ODdERTJfMzAwX3NxLmpwZw==\" }, { \"objectType\": \"<etc. etc.>\", \"content\": \"<some other content>\" }], \"content\": \"globalmod\", \"objectType\": \"user\" }] }] }, \"verb\": \"join\", \"target\": { \"id\": \"7935a673-da64-4419-818b-e6e0d1864b61\", \"displayName\": \"TG9k=\" }, \"id\": \"6a61c7a5-0ae0-4735-918d-18c9d137e43c\", \"published\": \"2019-07-05T06:18:30Z\", \"provider\": { \"id\": \"some-name\" } } } Attachments for each user contains the user data, e.g. user name, age, city etc. rename_room Responds with the event name gn_rename_room . Every other connected user will receive a gn_room_renamed event. Request example: { \"verb\": \"rename\", \"target\": { \"id\": \"<room ID>\", \"displayName\": \"<NEW room name in base64>\", \"objectType\": \"room\" } } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<room name in base64>\", \"objectType\": \"room\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"renamed\" } }","title":"API"},{"location":"md/api/#error-codes","text":"OK = 200 UNKNOWN_ERROR = 250 MISSING_ACTOR_ID = 500 MISSING_OBJECT_ID = 501 MISSING_TARGET_ID = 502 MISSING_OBJECT_URL = 503 MISSING_TARGET_DISPLAY_NAME = 504 MISSING_ACTOR_URL = 505 MISSING_OBJECT_CONTENT = 506 MISSING_OBJECT = 507 MISSING_OBJECT_ATTACHMENTS = 508 MISSING_ATTACHMENT_TYPE = 509 MISSING_ATTACHMENT_CONTENT = 510 INVALID_TARGET_TYPE = 600 INVALID_ACL_TYPE = 601 INVALID_ACL_ACTION = 602 INVALID_ACL_VALUE = 603 INVALID_STATUS = 604 INVALID_OBJECT_TYPE = 605 INVALID_BAN_DURATION = 606 EMPTY_MESSAGE = 700 NOT_BASE64 = 701 USER_NOT_IN_ROOM = 702 USER_IS_BANNED = 703 ROOM_ALREADY_EXISTS = 704 NOT_ALLOWED = 705 VALIDATION_ERROR = 706 ROOM_FULL = 707 NOT_ONLINE = 708 TOO_MANY_PRIVATE_ROOMS = 709 ROOM_NAME_TOO_LONG = 710 ROOM_NAME_TOO_SHORT = 711 INVALID_TOKEN = 712 INVALID_LOGIN = 713 MSG_TOO_LONG = 714 MULTIPLE_ROOMS_WITH_NAME = 715 TOO_MANY_ATTACHMENTS = 716 NOT_ENABLED = 717 ROOM_NAME_RESTRICTED = 718 NOT_ALLOWED_TO_WHISPER_USER = 719 NOT_ALLOWED_TO_WHISPER_CHANNEL = 720 NO_SUCH_USER = 800 NO_SUCH_CHANNEL = 801 NO_SUCH_ROOM = 802 NO_ADMIN_ROOM_FOUND = 803 NO_USER_IN_SESSION = 804 NO_ADMIN_ONLINE = 805","title":"Error Codes"},{"location":"md/api/#connect","text":"Responds with event name gn_connect . Request contains no data. Response data if successful: { \"status_code\": 200 }","title":"connect"},{"location":"md/api/#login","text":"Responds with event name gn_login . Request contains: { \"verb\": \"login\", \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<user name>\", \"attachments\": [ { \"objectType\": \"token\", \"content\": \"<user token>\" } ] } } Response data if successful: { \"status_code\": 200, \"data\": { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user id>\", \"displayName\": \"<user name in base64>\", \"attachments\": [ { \"objectType\": \"room_role\", \"id\": \"<room UUID>\", \"content\": \"moderator,owner\" }, { \"objectType\": \"room_role\", \"id\": \"<room UUID>\", \"content\": \"owner\" }, { \"objectType\": \"channel_role\", \"id\": \"<channel UUID>\", \"content\": \"admin,owner\" }, { \"objectType\": \"global_roles\", \"content\": \"superuser,globalmod\" } ] }, \"object\": { \"objectType\": \"history\", \"attachments\": [{ \"author\": { \"id\": \"<sender id>\", \"displayName\": \"<sender name in base64>\" }, \"content\": \"<message in base64>\", \"id\": \"84421980-d84a-4f6f-9ad7-0357d15d99f8\", \"published\": \"2017-11-17T07:19:12Z\", \"summary\": \"9fa5b40a-f0a6-44ea-93c1-acf2947e5f09\", \"objectType\": \"history\" }] }, \"verb\": \"login\" } } The object attachments are non-acked messages sent to any private room s (i.e. conversation based private messaging). The object.attachments[0].id is the message UUID, while the object.attachments[0].summary is the room UUID. Multiple attachments will be listed if more than one un-acked message was found during login. For the user roles, there will be an ID on the attached object if the role is for a channel or for a room. If it's a global role there will be no ID on the object. Roles are comma separated if more than one role for a room/channel/global. Possible roles are: global superuser (globalmod) channel owner (owner) channel admin (admin) room owner (owner) room moderator (moderator) The only difference between global moderator and super user is that the global moderators can't remove static rooms (ephemeral set to false in room list).","title":"login"},{"location":"md/api/#invisible-login","text":"See Invisibility docs.","title":"Invisible login"},{"location":"md/api/#list_channels","text":"Responds with event name gn_list_channels . Request contains: { \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"channels\", \"attachments\": [ { \"id\": \"<channel UUID>\", \"displayName\": \"<channel name>\", \"url\": 8, \"content\": \"normal,another-tag\", \"objectType\": \"static\", \"attachments\": [ { \"summary\": \"message\", \"objectType\": \"membership\", \"content\": \"1\" } ] }, { \"id\": \"<channel UUID>\", \"displayName\": \"<channel name>\", \"url\": 20, \"content\": \"another-tag\", \"objectType\": \"temporary\", \"attachments\": [ { \"summary\": \"join\", \"objectType\": \"gender\", \"content\": \"f\" } ] } ] }, \"verb\": \"list\" } } Each channel has a url field, which is the sort order defined in the admin interface, in ascending order (lower url means higher up in the list). The objectType of a channel tells you if this channel only contains static rooms, only temporary rooms or a mix of both. Possible values are thus: temporary static mix If the channel has 0 rooms in it, the objectType will be mix . The content field on each attachment specifies a comma separated list of tags for the channel. Attachments for each channel describes the ACLs for that channel.","title":"list_channels"},{"location":"md/api/#received","text":"Acknowledge that one or more messages has been received. The status will change from sent to delivered . Does not emit a response, only invokes the callback with the status_code and potentially and error_message . Note that if multiple messages are being acknowledged at the same time, they all have to be for the same room ( target.id ). Request contains: { \"verb\": \"receive\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } }","title":"received"},{"location":"md/api/#msg_status","text":"Check ack status of a set of messages sent to a single user. Request: { \"verb\": \"check\", \"target\": { \"id\": \"<uuid of the user to check ack status for>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } } If message guarantee is not enabled on the server the 717 ( NOT_ENABLED ) error code will be retured as part of the callback, and no gn_msg_status event will be sent back. Response will be sent as the gn_msg_status event with the following content: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"statuses\", \"attachments\": [ { \"id\": \"<msg UUID 1>\", \"content\": \"<ack status 1>\" }, { \"id\": \"<msg UUID 2>\", \"content\": \"<ack status 2>\" }, { \"id\": \"<msg UUID 3>\", \"content\": \"<ack status 3>\" } ] }, \"target\": { \"id\": \"<user ID the ack status are for>\" }, \"verb\": \"check\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } } The ack statuses are: 0: not acknowledged (receiver has not acked it yet) 1: received 2: read","title":"msg_status"},{"location":"md/api/#read","text":"Acknowledge that one or more messages has been read. The status will change from sent / delivered to read . Does not emit a response, only invokes the callback with the status_code and potentially and error_message . Note that if multiple messages are being acknowledged at the same time, they all have to be for the same room ( target.id ). Request contains: { \"verb\": \"read\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } } If the target.id is specified, the request will be relayed to online users in that room. E.g., user A sends message X to the room, user B then sends a read event after receiving it; this read event will then be sent to user A with the event name gn_message_read .","title":"read"},{"location":"md/api/#list_rooms","text":"Get a list of all rooms for a channel. Responds with event name gn_list_rooms . Request contains: { \"object\": { \"url\": \"<channel UUID>\" }, \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"rooms\", \"url\": \"<channel UUID>\", \"attachments\": [ { \"id\": \"<room UUID>\", \"displayName\": \"<room name>\", \"url\": 8, \"summary\": <number of users in this room (integer)>, \"objectType\": \"static\", \"content\": \"moderator,owner\", \"attachments\": [ { \"summary\": \"join\", \"objectType\": \"gender\", \"content\": \"f\" } ] }, { \"id\": \"<room UUID>\", \"displayName\": \"<room name>\", \"url\": 20, \"summary\": <number of users in this room (integer)>, \"objectType\": \"temporary\", \"content\": \"\", \"attachments\": [ { \"summary\": \"join\", \"objectType\": \"gender\", \"content\": \"f\" } ] } ] }, \"verb\": \"list\" } } The url field for object is the UUID of the channel that these rooms are for. Each room has a url field, which is the sort order defined in the admin interface, in ascending order (lower url means higher up in the list). The content field on the attachments describe what kind of role you have for that room. If no roles are set then content will be empty, otherwise it will be a comma separated list of roles. Possible roles for rooms are: moderator owner globalmod superuser Global roles and roles for channels are returned in the gn_login event. Attachments for each room describes the ACLs for that room. The objectType for each room describes if the room is static or temporary. Static rooms are not removed automatically when empty, while temporary rooms are removed when the owner leaves (usually only for user created rooms).","title":"list_rooms"},{"location":"md/api/#update_user_info","text":"If a user e.g. changes his/her avatar, the change can be broadcasted to users in the same rooms as this user is in. To e.g. let other users know this user is currently streaming video, the objectType is_streaming might be used: { \"object\": { \"attachments\": [ { \"content\": \"MA==\", \"objectType\": \"is_streaming\" } ], \"objectType\": \"userInfo\" }, \"verb\": \"update\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } The content of the attachments needs to be base64 encoded. Updates are saved in redis and thus will be included in the user info returned in gn_join and gn_users_in_room . Responds with event name gn_update_user_info . When the update is sent to other users it will be received as an event with name gn_user_info_updated . Response data if successful: { \"status_code\": 200 } Or if missing data, e.g.: { \"status_code\": 509, \"message\": \"no objectType on attachment for object\" }","title":"update_user_info"},{"location":"md/api/#request_admin","text":"When help is wanted in a room, a user can request for an admin to join and help out. Every channel has an Admin room, which only admins can see when listing rooms and only admins can join. When a request_admin event is sent to the server it will be delivered to the admin room for that channel and the admins in that room can decide what to do. Important: If no user with the global role superuser or globalmod is online, the 805 code will be returned (\"no admin is online\"). Responds with event name gn_request_admin . Request contains: { \"target\": { \"id\": \"<room UUID to request help for>\" }, \"object\": { \"content\": \"<base64 encoded message that will be delivered to the admin room>\" }, \"verb\": \"help\" } Response data if successful: { \"status_code\": 200 } If no admin is online, the response will be: { \"status_code\": 805, \"message\": \"no admin is online\" } The object.content could be anything, e.g. a base64 encoded json message with link to backend, extra information, a reason text etc. The event generated to be sent to the admin room is called gn_admin_requested (see Events for more information).","title":"request_admin"},{"location":"md/api/#leave","text":"Leave a room. Responds with event name gn_leave . Request contains: { \"target\": { \"id\": \"<room UUID>\" }, \"verb\": \"leave\" } Or, if you want to leave a room based on the room name: { \"verb\": \"join\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } Response data if successful: { \"status_code\": 200 }","title":"leave"},{"location":"md/api/#users_in_room","text":"List all users in a room. Responds with event name gn_users_in_room . Request contains: { \"target\": { \"id\": \"<room UUID>\" }, \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"users\", \"attachments\": [ { \"id\": \"<user UUID>\", \"displayName\": \"<user name>\", \"content\": \"globalmod,moderator\" \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, { \"id\": \"<user UUID>\", \"displayName\": \"<user name>\", \"content\": \"moderator\" \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] } ] }, \"verb\": \"list\" } } The content of the user attachment describes the roles this user has in this room, plus any global roles. Examples: globalmod,moderator moderator superuser If no specific roles, the value will be blank.","title":"users_in_room"},{"location":"md/api/#history","text":"TODO: include user UUID as well as user name. When joining a room the history will be included in the gn_join response event. If history is needed for a separate reason than the history event can be used. Can also be used to get history for a private chat with another user, if \"target.id\" is set to the user UUID instead of the room UUID. Responds with event name gn_history . Request contains: { \"target\": { \"id\": \"<room UUID>\" }, \"updated\": \"<last read timestamp, if configured in server will return messages since this time>\", \"verb\": \"list\" } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"messages\", \"attachments\": [ { \"author\": { \"id\": \"<the user id of the sender>\", \"displayName\": \"<the user name of the sender>\" }, \"id\": \"<message ID>\", \"content\": \"<the message content>\", \"published\": \"<the time it was sent, RFC3339>\" }, { \"author\": { \"id\": \"<the user id of the sender>\", \"displayName\": \"<the user name of the sender>\" }, \"id\": \"<message ID>\", \"content\": \"<the message content>\", \"published\": \"<the time it was sent, RFC3339>\" } ] }, \"target\": { \"id\": \"<room UUID>\" }, \"verb\": \"history\" } }","title":"history"},{"location":"md/api/#status","text":"Change the online status for this user. Responds with gn_status . Request contains: { \"verb\": \"<one of online/offline/invisible>\" } Response data if successful: { \"status_code\": 200 }","title":"status"},{"location":"md/api/#get_acl","text":"Get the permissions (ACL) for a channel or room. Responds with gn_get_acl . Request contains: { \"target\": { \"id\": \"<room UUID>\", \"objectType\": \"<room/channel>\" }, \"verb\": \"get\" } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<room/channel UUID>\", \"objectType\": \"<room/channel>\" }, \"object\": { \"objectType\": \"acl\", \"attachments\": [ { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" }, { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" } ] }, \"verb\": \"get\" } }","title":"get_acl"},{"location":"md/api/#set_acl","text":"Update the permissions of a room/channel. If the \"content\" is blank, the ACL with that type for the specified action will be removed. Example \"API actions\" are \"join\", \"create\", \"message\", \"kick\". Example \"permission types\" are \"age\", \"gender\", \"membership\". Responds with gn_set_acl . Request contains: { \"target\": { \"id\": \"<room/channel UUID>\", \"objectType\": \"<room/channel>\" }, \"object\": { \"objectType\": \"acl\", \"attachments\": [ { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" }, { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" } ] }, \"verb\": \"set\" } Response data if successful: { \"status_code\": 200 }","title":"set_acl"},{"location":"md/api/#create","text":"Create a new room under a channel. The sender of the event will be set as the first owner of the new room. Responds with gn_create . Request contains: { \"target\": { \"displayName\": \"<name of the new room>\" }, \"object\": { \"url\": \"<channel UUID>\" }, \"verb\": \"create\" } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<the generated UUID for this room>\", \"displayName\": \"<name of the new room>\", \"objectType\": \"temporary\" }, \"object\": { \"url\": \"<channel UUID>\" }, \"verb\": \"create\" } } If the amount of private rooms already exceed 2, the error code 709 ( TOO_MANY_PRIVATE_ROOMS ) will be returned. The target.objectType will always be temporary since all rooms created using the API are user created rooms, meaning they will be automatically removed when the owner leaves. It is also possible to specify ACLs for a room while creating it, but adding object.attachments as in the set_acl event: { \"target\": { \"displayName\": \"<name of the new room>\" }, \"object\": { \"url\": \"<channel UUID>\", \"objectType\": \"acl\", \"attachments\": [ { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" }, { \"objectType\": \"<ACL type name>\", \"content\": \"<ACL value>\", \"summary\": \"<API action, e.g. join/kick/etc>\" } ] }, \"verb\": \"create\" }","title":"create"},{"location":"md/api/#invite","text":"Invite another user to a room the current user is already in. Responds with gn_invite . Request contains: { \"target\": { \"id\": \"<UUID of the user to invite>\" }, \"actor\": { \"url\": \"<the room UUID the invitation is for>\" }, \"verb\": \"invite\" } Response data if successful: { \"status_code\": 200 }","title":"invite"},{"location":"md/api/#delete","text":"Delete a message from a room (needs to be superuser, admin for channel, owner of channel, moderator of the room, owner of room or (configurable) sender of the message). If object_type is set to room the object.id should be the UUID of a room. All messages in that room will then be deleted. If object_type is set to anything else, or not specified at all, then object.id is assumed to be the UUID of a single message. Responds with gn_delete . Request contains: { \"target\": { \"id\": \"<UUID of the room to delete from>\" }, \"object\": { \"id\": \"<UUID of the message to delete OR the UUID of the room to clear>\", \"object_type\": \"<optional; if set to 'room' the object.id is assumed to be the room id>\" }, \"verb\": \"delete\" }","title":"delete"},{"location":"md/api/#kick","text":"Kick a user from a room. Responds with gn_kick . Request contains: { \"actor\": { \"id\": \"<ID of the user who's kicking someone, leave black for admin ID>\" }, \"target\": { \"id\": \"<ID of the room to kick from>\" }, \"object\": { \"id\": \"<ID of the user to kick>\", \"content\": \"<optional reason field>\" }, \"verb\": \"kick\" } Response data if successful: { \"status_code\": 200 }","title":"kick"},{"location":"md/api/#ban","text":"Ban a user from a room for a given amount of time. Responds with gn_ban . Request contains: { \"actor\": { \"id\": \"<ID of the user who's banning someone; leave empty for admin ID>\" }, \"target\": { \"id\": \"<UUID of the room/channel to ban from>\", \"objectType\": \"<room/channel/global>\" }, \"object\": { \"id\": \"<UUID of the user to ban>\", \"summary\": \"<ban duration, an integer suffixed with one of [d, h, m, s]>\", \"content\": \"<optional reason field, base64>\" }, \"verb\": \"ban\" } If banning a used in a room, set objectType to room and target.id to the uuid of the room. If banning from a channel, set objectType to channel and target.id to the uuid of the channel. If banning globally, set objectType to global and skip target.id . Summary is the duration of the ban. It's a number with a suffix d, h, m or s, meaning days, hours, minutes and seconds. Only one suffix can be used. E.g.: 5m (ban for five minutes), 3600s (ban for 3600 seconds, same as 1h), 365d (ban for one year). It's not possible to permanently ban a user, but you can set a very large duration for the same effect. The only restriction is that the date when the ban ends ( utcnow()+duration ) must be before the year 10000 (date lib restriction). Response data if successful: { \"status_code\": 200 }","title":"ban"},{"location":"md/api/#message","text":"Send a message to a room UUID (can be the user UUID or an actual room UUID). Responds with event name gn_message . Request contains: { \"verb\": \"send\", \"target\": { \"id\": \"<room uuid>\", \"objectType\": \"<room/private>\" }, \"object\": { \"content\": \"<the message, base64 encoded>\", } } If request is for conversation-based private messaging, use objectType: 'private' . In this case, the other user(s) in this conversation ( owner s of the room ) will initially have a NOT_ACKED status for the message. If they are online they will receive it and they can acknowledge the message. If they are offline they will receive it in gn_login then they come online (all non-acked messages for rooms they are owner for). Response data if successful: { \"status_code\": 200, \"data\": { \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"actor\": { \"id\": \"<your user ID>\", \"displayName\": \"<your user name>\" }, \"verb\": \"send\", \"target\": { \"id\": \"<room ID>\", \"displayName\": \"<room name>\" }, \"object\": { \"content\": \"<the message>\", \"displayName\": \"<the channel name>\", \"url\": \"<the channel id>\", \"objectType\": \"<room/private>\" } } } The response will send the same ActivityStreams as was in the request, with the addition of a server generated ID (uuid) and the published field set to the time the server received the request (in RFC3339 format).","title":"message"},{"location":"md/api/#remove_room","text":"Response with the event name gn_remove_room . Request contains: { \"verb\": \"remove\", \"target\": { \"id\": \"<room ID>\" } } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<room name in base64>\", \"objectType\": \"room\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"removed\" } }","title":"remove_room"},{"location":"md/api/#report","text":"No response. Request contains: { \"verb\": \"report\", \"object\": { \"id\": \"<uuid of message>\", \"content\": \"<the actual message to report, base64>\", \"summary\": \"<optional reason text, base64>\" }, \"target\": { \"id\": \"<user ID to report>\" } } A report will be sent to both the admin room and as an external event published on the MQ.","title":"report"},{"location":"md/api/#join","text":"Responds with the event name gn_join . In the user attachments, the content fields tells you the room roles that the user has in this room (as a comma separated value), plus any global roles. Possible roles are: superuser, globalmod, owner, moderator, admin. Currently only the superuser and globalmod role is considered when the request_admin api is used. Request contains: { \"verb\": \"join\", \"target\": { \"id\": \"<room ID>\" } } Or, if you want to join a room based on the room name: { \"verb\": \"join\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } Response data if successful: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"room\", \"attachments\": [{ \"objectType\": \"acl\", \"attachments\": [] }, { \"objectType\": \"history\", \"attachments\": [{ \"author\": { \"id\": \"50327\", \"displayName\": \"Zmbw==\", \"attachments\": [{ \"objectType\": \"avatar\", \"content\": \"aHR0cDovLzAuYmlsZC5wb3BwZW4ubGFiL20QzdCOUI5XzMwMF9zcS5qcGc=\" }, { \"objectType\": \"app_avatar\", \"content\": \"aHR0cDovLzAuaW1nLnBvcGNvcm4NTAwNDMyNy1GOUI4RjBDNjBBlCOV8zMDBfc3EuanBn\" }, { \"objectType\": \"app_avatar_safe\", \"content\": \"aHR0cDovLzAuaW1nLnBvcGNvcTAwNDMyNy1GOUI4RjBDN3QjlCOV8zMDBfc3EuanBn\" }] }, \"summary\": \"7935a673-da64-4419-818b-e6e0d1864b61\", \"id\": \"d02598a1-6ae6-4182-8f2c-c2e66d941303\", \"content\": \"eyJjb2xvciI6IjiwiZ2nRlOiJkc2EifQ==\", \"published\": \"2019-07-04T07:45:59Z\" }] }, { \"objectType\": \"owner\", \"attachments\": [{ \"id\": \"0\", \"displayName\": \"QWW4=\" }] }, { \"objectType\": \"user\", \"attachments\": [{ \"id\": \"5048\", \"displayName\": \"am8yaw==\", \"attachments\": [{ \"objectType\": \"region\", \"content\": \"Qmlu\" }, { \"objectType\": \"avatar\", \"content\": \"aHR0cDovLzAuYmOTgxRjhBNUM0NDA5MDQ2MDA4ODdERTJfMzAwX3NxLmpwZw==\" }, { \"objectType\": \"<etc. etc.>\", \"content\": \"<some other content>\" }], \"content\": \"globalmod\", \"objectType\": \"user\" }] }] }, \"verb\": \"join\", \"target\": { \"id\": \"7935a673-da64-4419-818b-e6e0d1864b61\", \"displayName\": \"TG9k=\" }, \"id\": \"6a61c7a5-0ae0-4735-918d-18c9d137e43c\", \"published\": \"2019-07-05T06:18:30Z\", \"provider\": { \"id\": \"some-name\" } } } Attachments for each user contains the user data, e.g. user name, age, city etc.","title":"join"},{"location":"md/api/#rename_room","text":"Responds with the event name gn_rename_room . Every other connected user will receive a gn_room_renamed event. Request example: { \"verb\": \"rename\", \"target\": { \"id\": \"<room ID>\", \"displayName\": \"<NEW room name in base64>\", \"objectType\": \"room\" } } Response data if successful: { \"status_code\": 200, \"data\": { \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<room name in base64>\", \"objectType\": \"room\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"renamed\" } }","title":"rename_room"},{"location":"md/events/","text":"Message deleted When an admin/mod/etc. deletes a message from a room, everyone on that room will receive an event with the name gn_message_deleted so they can remove it locally as well. { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"object\": { \"id\": \"<UUID of the message that was deleted>\" }, \"target\": { \"id\": \"<UUID of the room the message was deleted in>\" }, \"verb\": \"delete\", \"actor\": { \"id\": \"<ID of the user who deleted the message>\", \"displayName\": \"<name of the user, base64>\" } } Message received When user A receives a private message, or a message from a room that user A is in, the event message will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of the sender>\", \"displayName\": \"<name of the sender>\" }, \"verb\": \"send\", \"target\": { \"id\": \"<UUID of the room, or this user's UUID if private msg>\", \"displayName\": \"<name of the room, or target user name if private msg>\", \"objectType\": \"<room/private>\" }, \"object\": { \"content\": \"<the message body>\", \"displayName\": \"<the name of the channel, or empty if private msg>\", \"url\": \"<UUID of the channel for this room, or empty if private msg>\" } } Message has been read If user A sends a message to user B and user B invokes the read api to indicate the message has been read, user A will receive a gn_message_read event with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user id of the one sending the read receipt>\" }, \"verb\": \"read\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } } Message has been delivered If user A sends a message to user B and user B invokes the received api to indicate the message has been received, user A will receive a gn_message_received event with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user id of the one sending the read receipt>\" }, \"verb\": \"received\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } } User info updated When a user updates his/her user information (e.g. avatar, is streaming, age etc.), the event gn_user_info_updated will be sent to either all rooms that the user is in, or a specific room that user chose to send to. The event looks like this: { \"actor\": { \"id\": \"997110\", \"displayName\": \"YmF0bWFu\" }, \"object\": { \"attachments\": [{ \"content\": \"MA==\", \"objectType\": \"streaming\" },{ \"content\": \"MzU=\", \"objectType\": \"age\" }], \"objectType\": \"userInfo\" }, \"verb\": \"update\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } The content on each attachment is always base64 encoded. The objectType tells which field has been updated. Possible values depends on implementation, but is usually same as what's returned for user info when joining a room ( gn_join ). Admin presence requested When someone requests the presence of an admin in a room all users in the Admin room for that channel will receive an event called gn_admin_requested containing the following: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of user requesting>\", \"displayName\": \"<name of the user requesting>\",, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"verb\": \"help\", \"object\": { \"content\": \"<base64 encoded message>\" }, \"generator\": { \"id\": \"<UUID of the room the help was requested for>\", \"displayName\": \"<name of the room>\" }, \"target\": { \"id\": \"<UUID of the admin room>\", \"displayName\": \"<base64 of the admin room name>\" } } A room was removed When a room is removed by an admin/owner an event called gn_room_removed will be sent to everyone on the server (to keep the room list in sync on client side): { \"actor\": { \"id\": \"<user ID who removed the room>\", \"displayName\": \"<name of the user who removed the room, in base64>\" }, \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<room name in base64>\", \"objectType\": \"room\" }, \"object\": { \"content\": \"<an optional reason, in base64>\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"removed\" } A room was renamed When a room is renamed by an admin/owner an event called gn_room_renamed will be sent to everyone on the server (to keep the room list in sync on client side): { \"actor\": { \"id\": \"<user ID who renamed the room>\", \"displayName\": \"<name of the user who renamed the room, in base64>\" }, \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<NEW room name in base64>\", \"objectType\": \"room\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"renamed\" } Invitation received When user B invites user A to join room X, the event gn_invitation will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of user B>\", \"displayName\": \"<name of user B>\",, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"verb\": \"invite\", \"object\": { \"url\": \"<UUID of the channel for room X>\", \"displayName\": \"<name of the channel for room X>\" }, \"target\": { \"id\": \"<UUID of the room>\", \"displayName\": \"<name of the room>\" } } Another user joins the room If user A is in room X, and another user B joins room X, the server will send an event called gn_user_joined to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", \"content\": \"globalmod,moderator\" \"image\": { \"url\": \"<user B's image url>\" }, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"target\": { \"id\": \"<uuid of the room>\", \"displayName\": \"<name of the room>\" }, \"verb\": \"join\" } The actor.content describes the roles this user has in this room, plus any global roles. Examples: globalmod,moderator moderator superuser If no specific roles, the value will be blank. Another user leaves room When user A is in room X, and another user B leaves room X, the sever will send an event called gn_user_left to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", }, \"target\": { \"id\": \"<uuid of the room>\", \"displayName\": \"<name of the room>\" }, \"verb\": \"leave\" } Another user connects When a user connects (or stops being invisible), the gn_user_connected event will be sent. { \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"verb\": \"connect\" } Another user disconnects If user A is in any room that user B is in, and user B disconnects from the chat server, an event called gn_user_disconnected will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", }, \"verb\": \"disconnect\" } You were banned If you are banned, either in a room, a channel or globally, you will receive the following event named gn_banned : { \"actor\": { \"id\": \"<ID of the one who banned you>\", \"displayName\": \"<username of the one who banned you, in base64>\" }, \"object\": { \"id\": \"<your user ID>\", \"displayName\": \"<your username in base64>\", \"summary\": \"30s\", \"updated\": \"2017-02-15T09:11:52Z\", \"content\": \"<the reason for the ban>\" }, \"target\": { \"id\": \"<room/channel uuid>\", \"displayName\": \"<room/channel name, in base64>\", \"objectType\": \"<room/channel/global>\" }, \"verb\": \"ban\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } target.id and target.displayName will not be present if target.objectType is \"global\", object.summary is the duration of the ban, e.g. 30s, 2h, 7d etc., object.updated is the timestamp when the ban will expire, in UTC, object.content is the reason for the ban, but if no reason is given by the banned, this field will not be present. A new room is created When a new room is created in a channel that user A is in, an event called gn_room_created will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of user who created the room>\", \"displayName\": \"<name of the user who created the room>\",, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"object\": { \"url\": \"<UUID of the channel for this room>\" }, \"target\": { \"id\": \"<UUID of the new room>\", \"displayName\": \"<name of the new room>\", \"objectType\": \"temporary\" }, \"verb\": \"create\" } The target.objectType will always be temporary since all rooms created using the API are user created rooms, meaning they will be automatically removed when the owner leaves. A user is kicked from a room When a user is kicked from a room, an event will be sent to all users in that room (except the kicked user), called gn_user_kicked , with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of the kicker>\", \"displayName\": \"<name of the kicker>\", \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"object\": { \"id\": \"<UUID of the kicked user>\", \"displayName\": \"<name of the kicked user>\", \"content\": \"<optional reason field>\", \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"target\": { \"id\": \"<UUID of the room the user was kicked from>\", \"displayName\": \"<name of the room the user was kicked from>\" }, \"verb\": \"kick\" } Broadcast received When a message is broadcasted to every user on the server, a gn_broadcast event is received: { \"actor\": { \"displayName\": \"<admin in base64>\", \"id\": \"0\" }, \"content\": \"<base64>\", \"verb\": \"broadcast\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"provider\": { \"id\": \"popp\" } } A user is banned TODO: currently the user will be banned, but the \"kicked\" event will be broadcasted to relevant users. There's currently no \"banned\" event for this.","title":"Events"},{"location":"md/events/#message-deleted","text":"When an admin/mod/etc. deletes a message from a room, everyone on that room will receive an event with the name gn_message_deleted so they can remove it locally as well. { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"object\": { \"id\": \"<UUID of the message that was deleted>\" }, \"target\": { \"id\": \"<UUID of the room the message was deleted in>\" }, \"verb\": \"delete\", \"actor\": { \"id\": \"<ID of the user who deleted the message>\", \"displayName\": \"<name of the user, base64>\" } }","title":"Message deleted"},{"location":"md/events/#message-received","text":"When user A receives a private message, or a message from a room that user A is in, the event message will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of the sender>\", \"displayName\": \"<name of the sender>\" }, \"verb\": \"send\", \"target\": { \"id\": \"<UUID of the room, or this user's UUID if private msg>\", \"displayName\": \"<name of the room, or target user name if private msg>\", \"objectType\": \"<room/private>\" }, \"object\": { \"content\": \"<the message body>\", \"displayName\": \"<the name of the channel, or empty if private msg>\", \"url\": \"<UUID of the channel for this room, or empty if private msg>\" } }","title":"Message received"},{"location":"md/events/#message-has-been-read","text":"If user A sends a message to user B and user B invokes the read api to indicate the message has been read, user A will receive a gn_message_read event with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user id of the one sending the read receipt>\" }, \"verb\": \"read\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } }","title":"Message has been read"},{"location":"md/events/#message-has-been-delivered","text":"If user A sends a message to user B and user B invokes the received api to indicate the message has been received, user A will receive a gn_message_received event with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user id of the one sending the read receipt>\" }, \"verb\": \"received\", \"target\": { \"id\": \"<uuid of the room the messages are all in>\" }, \"object\": { \"attachments\": [ {\"id\": \"<message1 uuid>\"}, {\"id\": \"<message2 uuid>\"}, {\"id\": \"<message3 uuid>\"} ] } }","title":"Message has been delivered"},{"location":"md/events/#user-info-updated","text":"When a user updates his/her user information (e.g. avatar, is streaming, age etc.), the event gn_user_info_updated will be sent to either all rooms that the user is in, or a specific room that user chose to send to. The event looks like this: { \"actor\": { \"id\": \"997110\", \"displayName\": \"YmF0bWFu\" }, \"object\": { \"attachments\": [{ \"content\": \"MA==\", \"objectType\": \"streaming\" },{ \"content\": \"MzU=\", \"objectType\": \"age\" }], \"objectType\": \"userInfo\" }, \"verb\": \"update\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } The content on each attachment is always base64 encoded. The objectType tells which field has been updated. Possible values depends on implementation, but is usually same as what's returned for user info when joining a room ( gn_join ).","title":"User info updated"},{"location":"md/events/#admin-presence-requested","text":"When someone requests the presence of an admin in a room all users in the Admin room for that channel will receive an event called gn_admin_requested containing the following: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of user requesting>\", \"displayName\": \"<name of the user requesting>\",, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"verb\": \"help\", \"object\": { \"content\": \"<base64 encoded message>\" }, \"generator\": { \"id\": \"<UUID of the room the help was requested for>\", \"displayName\": \"<name of the room>\" }, \"target\": { \"id\": \"<UUID of the admin room>\", \"displayName\": \"<base64 of the admin room name>\" } }","title":"Admin presence requested"},{"location":"md/events/#a-room-was-removed","text":"When a room is removed by an admin/owner an event called gn_room_removed will be sent to everyone on the server (to keep the room list in sync on client side): { \"actor\": { \"id\": \"<user ID who removed the room>\", \"displayName\": \"<name of the user who removed the room, in base64>\" }, \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<room name in base64>\", \"objectType\": \"room\" }, \"object\": { \"content\": \"<an optional reason, in base64>\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"removed\" }","title":"A room was removed"},{"location":"md/events/#a-room-was-renamed","text":"When a room is renamed by an admin/owner an event called gn_room_renamed will be sent to everyone on the server (to keep the room list in sync on client side): { \"actor\": { \"id\": \"<user ID who renamed the room>\", \"displayName\": \"<name of the user who renamed the room, in base64>\" }, \"target\": { \"id\": \"<room uuid>\", \"displayName\": \"<NEW room name in base64>\", \"objectType\": \"room\" }, \"id\": \"c42ebf01-3d50-4f27-a345-4ed213be045d\", \"published\": \"2016-10-07T10:45:34Z\", \"verb\": \"renamed\" }","title":"A room was renamed"},{"location":"md/events/#invitation-received","text":"When user B invites user A to join room X, the event gn_invitation will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of user B>\", \"displayName\": \"<name of user B>\",, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"verb\": \"invite\", \"object\": { \"url\": \"<UUID of the channel for room X>\", \"displayName\": \"<name of the channel for room X>\" }, \"target\": { \"id\": \"<UUID of the room>\", \"displayName\": \"<name of the room>\" } }","title":"Invitation received"},{"location":"md/events/#another-user-joins-the-room","text":"If user A is in room X, and another user B joins room X, the server will send an event called gn_user_joined to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", \"content\": \"globalmod,moderator\" \"image\": { \"url\": \"<user B's image url>\" }, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"target\": { \"id\": \"<uuid of the room>\", \"displayName\": \"<name of the room>\" }, \"verb\": \"join\" } The actor.content describes the roles this user has in this room, plus any global roles. Examples: globalmod,moderator moderator superuser If no specific roles, the value will be blank.","title":"Another user joins the room"},{"location":"md/events/#another-user-leaves-room","text":"When user A is in room X, and another user B leaves room X, the sever will send an event called gn_user_left to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", }, \"target\": { \"id\": \"<uuid of the room>\", \"displayName\": \"<name of the room>\" }, \"verb\": \"leave\" }","title":"Another user leaves room"},{"location":"md/events/#another-user-connects","text":"When a user connects (or stops being invisible), the gn_user_connected event will be sent. { \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"verb\": \"connect\" }","title":"Another user connects"},{"location":"md/events/#another-user-disconnects","text":"If user A is in any room that user B is in, and user B disconnects from the chat server, an event called gn_user_disconnected will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<user B's UUID>\", \"displayName\": \"<name of user B>\", }, \"verb\": \"disconnect\" }","title":"Another user disconnects"},{"location":"md/events/#you-were-banned","text":"If you are banned, either in a room, a channel or globally, you will receive the following event named gn_banned : { \"actor\": { \"id\": \"<ID of the one who banned you>\", \"displayName\": \"<username of the one who banned you, in base64>\" }, \"object\": { \"id\": \"<your user ID>\", \"displayName\": \"<your username in base64>\", \"summary\": \"30s\", \"updated\": \"2017-02-15T09:11:52Z\", \"content\": \"<the reason for the ban>\" }, \"target\": { \"id\": \"<room/channel uuid>\", \"displayName\": \"<room/channel name, in base64>\", \"objectType\": \"<room/channel/global>\" }, \"verb\": \"ban\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } target.id and target.displayName will not be present if target.objectType is \"global\", object.summary is the duration of the ban, e.g. 30s, 2h, 7d etc., object.updated is the timestamp when the ban will expire, in UTC, object.content is the reason for the ban, but if no reason is given by the banned, this field will not be present.","title":"You were banned"},{"location":"md/events/#a-new-room-is-created","text":"When a new room is created in a channel that user A is in, an event called gn_room_created will be sent to user A with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of user who created the room>\", \"displayName\": \"<name of the user who created the room>\",, \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"object\": { \"url\": \"<UUID of the channel for this room>\" }, \"target\": { \"id\": \"<UUID of the new room>\", \"displayName\": \"<name of the new room>\", \"objectType\": \"temporary\" }, \"verb\": \"create\" } The target.objectType will always be temporary since all rooms created using the API are user created rooms, meaning they will be automatically removed when the owner leaves.","title":"A new room is created"},{"location":"md/events/#a-user-is-kicked-from-a-room","text":"When a user is kicked from a room, an event will be sent to all users in that room (except the kicked user), called gn_user_kicked , with the following content: { \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"actor\": { \"id\": \"<UUID of the kicker>\", \"displayName\": \"<name of the kicker>\", \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"object\": { \"id\": \"<UUID of the kicked user>\", \"displayName\": \"<name of the kicked user>\", \"content\": \"<optional reason field>\", \"attachments\": [ { \"content\": \"NDA=\", \"objectType\": \"age\" }, { \"content\": \"aHR0cDovL3NvbWUtdXJsLnRsZC9mb28uanBn\", \"objectType\": \"avatar\" } ] }, \"target\": { \"id\": \"<UUID of the room the user was kicked from>\", \"displayName\": \"<name of the room the user was kicked from>\" }, \"verb\": \"kick\" }","title":"A user is kicked from a room"},{"location":"md/events/#broadcast-received","text":"When a message is broadcasted to every user on the server, a gn_broadcast event is received: { \"actor\": { \"displayName\": \"<admin in base64>\", \"id\": \"0\" }, \"content\": \"<base64>\", \"verb\": \"broadcast\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\", \"provider\": { \"id\": \"popp\" } }","title":"Broadcast received"},{"location":"md/events/#a-user-is-banned","text":"TODO: currently the user will be banned, but the \"kicked\" event will be broadcasted to relevant users. There's currently no \"banned\" event for this.","title":"A user is banned"},{"location":"md/external_events/","text":"External events are activity streams send to the configured external queue (e.g. RabbitMQ). User was kicked from a room Example of activity posted to the external queue: { \"actor\": { \"displayName\": \"admin\", \"id\": \"0\" }, \"object\": { \"displayName\": \"YXNkZg==\", \"content\": \"dGhpcyBpcyBhIHJlYXNvbg==\", \"id\": \"197114\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"kick\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } actor.id: ID of the user who kicked, or 0 if from admin interface, actor.displayName: name of the user who kicked, or admin if from admin interface, object.id: ID of the user who got kicked, object.content: base64 encoded \"reason\" for the kick (optional), object.displayName: base64 encoded username of the user was kicked, target.id: UUID of the room the user was kicked from, target.displayName: base64 encoded name of the room. User used a blacklisted word { \"actor\": { \"displayName\": \"YmF0bWFu\", \"id\": \"997110\" }, \"object\": { \"content\": \"aGVsbG8gZnVjayB5b3U=\", \"summary\": \"ZnVjaw==\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"blacklisted\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } target.displayName: name of the room the message was sent in, target.id: uuid of the room the message was sent in, actor.id: id of the user who sent the message, actor.displayName: username of the user who sent the message, object.content: the full message that was sent, object.summary: the forbidden word that was used. User send a message that got classified as a spam message { \"actor\": { \"displayName\": \"YmF0bWFu\", \"id\": \"997110\" }, \"object\": { \"content\": \"aGVsbG8gZnVjayB5b3U=\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"spam\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } target.displayName: name of the room the message was sent in, target.id: uuid of the room the message was sent in, actor.id: id of the user who sent the message, actor.displayName: username of the user who sent the message, object.content: the full message that was sent, User was banned Example of activity posted to the external queue: { \"actor\": { \"displayName\": \"admin\", \"id\": \"0\" }, \"object\": { \"displayName\": \"YXNkZg==\", \"id\": \"1234\", \"summary\": \"5m\", \"content\": \"dGhpcyBpcyBhIHJlYXNvbg==\", \"updated\": \"2016-12-22T07:13:09Z\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"objectType\": \"room\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"ban\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } actor.id: ID of the user who banned, or 0 if from admin interface, actor.displayName: name of the user who banned, or admin if from admin interface, object.id: ID of the user who got banned, object.displayName: base64 encoded username of the user was banned, object.content: base64 encoded \"reason\" for the ban (optional), object.summary: the ban duration, object.updated: the datetime when the ban will expire (in UTC), target.id: UUID of the room the user was kicked from, target.displayName: base64 encoded name of the room, target.objectType: one of \"room\", \"channel\", \"global\" (if \"global\", no displayName or id will be on target) Server restarted When the server REST node starts up it will sent a restart event in this format: { \"verb\": \"restart\", \"id\": \"c694ddc3-1b2b-4d43-ae5a-a843c2dce8aa\", \"published\": \"2017-06-09T07:26:26Z\" } User joins room When a user joins a room the following activity is published to rabbitmq: { \"object\": { \"attachments\": [{ \"content\": \"MA==\", \"objectType\": \"membership\" }, { \"content\": \"eQ==\", \"objectType\": \"image\" }, { \"content\": \"bQ==\", \"objectType\": \"gender\" }, { \"content\": \"NzA=\", \"objectType\": \"age\" }, { \"content\": \"c2hhbmdoYWk=\", \"objectType\": \"city\" }, { \"content\": \"Y24=\", \"objectType\": \"country\" }, { \"content\": \"eQ==\", \"objectType\": \"fake_checked\" }, { \"content\": \"eQ==\", \"objectType\": \"has_webcam\" }] }, \"target\": { \"displayName\": \"YmFkIGtpZHo=\", \"id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\" }, \"id\": \"bfa26b43-492f-4ec9-a83e-32e64ba2bc51\", \"actor\": { \"displayName\": \"YXNvZGZpaGFzZG9maWg=\", \"id\": \"385280\", \"image\": { \"url\": \"n\" } }, \"published\": \"2017-01-04T09:58:37Z\", \"verb\": \"join\" } User ban was removed Example of activity when a user's ban was manually removed in the admin interface: { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"target\": { \"id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"displayName\": \"YmFkIGtpZHo=\", \"objectType\": \"room\" }, \"published\": \"2017-01-03T05:50:11Z\", \"verb\": \"unban\", \"id\": \"49b067bb-79fe-48bd-9c03-dc4fd8f60192\", \"object\": { \"id\": \"124352\", \"displayName\": \"Zm9vYmFyenoyMw==\" } } target.id: room ID or channel ID target.objectType: \"room\", \"channel\" or \"global\" object.id: ID of the user object.displayName: name fo the user If target.objectType is global then no target.id or target.displayName will be included. User sends a message to a room/user Whenever a user sends a message an event will be published to the configured MQ, so another system can analyze activity level of users. Example activity: { \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<base64 encoded username>\" }, \"object\" { \"id\": \"<uuid of the message that was sent>\" }, \"verb\": \"send\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } One session has ended Multiple session can exist for a single user. A disconnect event is only sent when the last session has been closed, but a \"session closed\" event is sent for each session that is closed. Example activity: { \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<base64 encoded username>\", \"content\": \"<session UUID>\" }, \"verb\": \"ended\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } User successfully logged in Example of activity when a user successfully logs in: { \"id\": \"2190e4b9-6b80-4d86-992f-e107ae19be96\", \"title\": \"dino.wio.login\", \"actor\": { \"id\": \"1971\", \"attachments\": [{ \"objectType\": \"lon\", \"content\": \"11.11667\" }, { \"objectType\": \"lat\", \"content\": \"59.23891\" }, { \"objectType\": \"city\", \"content\": \"Berlin\" }, { \"objectType\": \"membership\", \"content\": \"vip\" }, { \"objectType\": \"is_streaming\", \"content\": \"False\" }, { \"objectType\": \"fakecheck\", \"content\": \"1\" }, { \"objectType\": \"country\", \"content\": \"Germany\" }, { \"objectType\": \"gender\", \"content\": \"m\" }, { \"objectType\": \"user_agent\", \"content\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36\" }, { \"objectType\": \"age\", \"content\": \"65\" }, { \"objectType\": \"search_gender\", \"content\": \"a,b\" }, { \"objectType\": \"avatar\", \"content\": \"http://img.example.com/m/avatar/19/1/f6/3/71-B833EE35D296C9BE_300_sq.jpg\" }, { \"objectType\": \"region\", \"content\": \"Berlin\" }, { \"objectType\": \"user_agent_platform\", \"content\": \"linux\" }, { \"objectType\": \"user_agent\", \"content\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36\" }, { \"objectType\": \"user_agent_browser\", \"content\": \"chrome\" }, { \"objectType\": \"user_agent_language\", \"content\": \"\" }, { \"objectType\": \"user_agent_version\", \"content\": \"63.0.3239.108\" }], \"displayName\": \"Um9iYnk=\", \"content\": \"<session UUID>\" }, \"provider\": { \"id\": \"wioenv\" }, \"verb\": \"login\", \"published\": \"2018-09-17T05:25:38Z\" } A user was reported for a message he/she sent A message may be reported in the front-end, and a report will be published to the MQ. The event looks like this: { \"actor\": { \"id\": \"<user ID that reported the message>\", \"displayName\": \"<the user name who reported the message>\" }, \"object\": { \"id\": \"<uuid of message>\", \"content\": \"<the actual message to report, base64>\", \"summary\": \"<optional reason text, base64>\" }, \"target\": { \"id\": \"<user ID to report>\", \"displayName\": \"<the user name of the reported user>\" }, \"verb\": \"report\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } User disconnected Example of activity when a user disconnects: { \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<base64 encoded username>\" }, \"verb\": \"disconnect\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } User becomes invisible When a user changes the status to become invisible the following event is published to the external queue: { \"id\": \"<server-generated UUID>\", \"actor\": { \"id\": \"635328\", \"displayName\": \"amtia2prYmJrag==\" }, \"verb\": \"invisible\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } User becomes visible after being in visible When a user changes his status to become visible again after being invisible the following event is sent to the external queue: { \"id\": \"<server-generated UUID>\", \"actor\": { \"id\": \"635328\", \"displayName\": \"amtia2prYmJrag==\" }, \"verb\": \"online\", \"published\": \"<server-generated timestamp, RFC3339 format>\" }","title":"External Events"},{"location":"md/external_events/#user-was-kicked-from-a-room","text":"Example of activity posted to the external queue: { \"actor\": { \"displayName\": \"admin\", \"id\": \"0\" }, \"object\": { \"displayName\": \"YXNkZg==\", \"content\": \"dGhpcyBpcyBhIHJlYXNvbg==\", \"id\": \"197114\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"kick\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } actor.id: ID of the user who kicked, or 0 if from admin interface, actor.displayName: name of the user who kicked, or admin if from admin interface, object.id: ID of the user who got kicked, object.content: base64 encoded \"reason\" for the kick (optional), object.displayName: base64 encoded username of the user was kicked, target.id: UUID of the room the user was kicked from, target.displayName: base64 encoded name of the room.","title":"User was kicked from a room"},{"location":"md/external_events/#user-used-a-blacklisted-word","text":"{ \"actor\": { \"displayName\": \"YmF0bWFu\", \"id\": \"997110\" }, \"object\": { \"content\": \"aGVsbG8gZnVjayB5b3U=\", \"summary\": \"ZnVjaw==\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"blacklisted\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } target.displayName: name of the room the message was sent in, target.id: uuid of the room the message was sent in, actor.id: id of the user who sent the message, actor.displayName: username of the user who sent the message, object.content: the full message that was sent, object.summary: the forbidden word that was used.","title":"User used a blacklisted word"},{"location":"md/external_events/#user-send-a-message-that-got-classified-as-a-spam-message","text":"{ \"actor\": { \"displayName\": \"YmF0bWFu\", \"id\": \"997110\" }, \"object\": { \"content\": \"aGVsbG8gZnVjayB5b3U=\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"spam\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } target.displayName: name of the room the message was sent in, target.id: uuid of the room the message was sent in, actor.id: id of the user who sent the message, actor.displayName: username of the user who sent the message, object.content: the full message that was sent,","title":"User send a message that got classified as a spam message"},{"location":"md/external_events/#user-was-banned","text":"Example of activity posted to the external queue: { \"actor\": { \"displayName\": \"admin\", \"id\": \"0\" }, \"object\": { \"displayName\": \"YXNkZg==\", \"id\": \"1234\", \"summary\": \"5m\", \"content\": \"dGhpcyBpcyBhIHJlYXNvbg==\", \"updated\": \"2016-12-22T07:13:09Z\" }, \"target\": { \"displayName\": \"Y29vbCBndXlz\", \"objectType\": \"room\", \"id\": \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\" }, \"verb\": \"ban\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" } actor.id: ID of the user who banned, or 0 if from admin interface, actor.displayName: name of the user who banned, or admin if from admin interface, object.id: ID of the user who got banned, object.displayName: base64 encoded username of the user was banned, object.content: base64 encoded \"reason\" for the ban (optional), object.summary: the ban duration, object.updated: the datetime when the ban will expire (in UTC), target.id: UUID of the room the user was kicked from, target.displayName: base64 encoded name of the room, target.objectType: one of \"room\", \"channel\", \"global\" (if \"global\", no displayName or id will be on target)","title":"User was banned"},{"location":"md/external_events/#server-restarted","text":"When the server REST node starts up it will sent a restart event in this format: { \"verb\": \"restart\", \"id\": \"c694ddc3-1b2b-4d43-ae5a-a843c2dce8aa\", \"published\": \"2017-06-09T07:26:26Z\" }","title":"Server restarted"},{"location":"md/external_events/#user-joins-room","text":"When a user joins a room the following activity is published to rabbitmq: { \"object\": { \"attachments\": [{ \"content\": \"MA==\", \"objectType\": \"membership\" }, { \"content\": \"eQ==\", \"objectType\": \"image\" }, { \"content\": \"bQ==\", \"objectType\": \"gender\" }, { \"content\": \"NzA=\", \"objectType\": \"age\" }, { \"content\": \"c2hhbmdoYWk=\", \"objectType\": \"city\" }, { \"content\": \"Y24=\", \"objectType\": \"country\" }, { \"content\": \"eQ==\", \"objectType\": \"fake_checked\" }, { \"content\": \"eQ==\", \"objectType\": \"has_webcam\" }] }, \"target\": { \"displayName\": \"YmFkIGtpZHo=\", \"id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\" }, \"id\": \"bfa26b43-492f-4ec9-a83e-32e64ba2bc51\", \"actor\": { \"displayName\": \"YXNvZGZpaGFzZG9maWg=\", \"id\": \"385280\", \"image\": { \"url\": \"n\" } }, \"published\": \"2017-01-04T09:58:37Z\", \"verb\": \"join\" }","title":"User joins room"},{"location":"md/external_events/#user-ban-was-removed","text":"Example of activity when a user's ban was manually removed in the admin interface: { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"target\": { \"id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"displayName\": \"YmFkIGtpZHo=\", \"objectType\": \"room\" }, \"published\": \"2017-01-03T05:50:11Z\", \"verb\": \"unban\", \"id\": \"49b067bb-79fe-48bd-9c03-dc4fd8f60192\", \"object\": { \"id\": \"124352\", \"displayName\": \"Zm9vYmFyenoyMw==\" } } target.id: room ID or channel ID target.objectType: \"room\", \"channel\" or \"global\" object.id: ID of the user object.displayName: name fo the user If target.objectType is global then no target.id or target.displayName will be included.","title":"User ban was removed"},{"location":"md/external_events/#user-sends-a-message-to-a-roomuser","text":"Whenever a user sends a message an event will be published to the configured MQ, so another system can analyze activity level of users. Example activity: { \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<base64 encoded username>\" }, \"object\" { \"id\": \"<uuid of the message that was sent>\" }, \"verb\": \"send\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" }","title":"User sends a message to a room/user"},{"location":"md/external_events/#one-session-has-ended","text":"Multiple session can exist for a single user. A disconnect event is only sent when the last session has been closed, but a \"session closed\" event is sent for each session that is closed. Example activity: { \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<base64 encoded username>\", \"content\": \"<session UUID>\" }, \"verb\": \"ended\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" }","title":"One session has ended"},{"location":"md/external_events/#user-successfully-logged-in","text":"Example of activity when a user successfully logs in: { \"id\": \"2190e4b9-6b80-4d86-992f-e107ae19be96\", \"title\": \"dino.wio.login\", \"actor\": { \"id\": \"1971\", \"attachments\": [{ \"objectType\": \"lon\", \"content\": \"11.11667\" }, { \"objectType\": \"lat\", \"content\": \"59.23891\" }, { \"objectType\": \"city\", \"content\": \"Berlin\" }, { \"objectType\": \"membership\", \"content\": \"vip\" }, { \"objectType\": \"is_streaming\", \"content\": \"False\" }, { \"objectType\": \"fakecheck\", \"content\": \"1\" }, { \"objectType\": \"country\", \"content\": \"Germany\" }, { \"objectType\": \"gender\", \"content\": \"m\" }, { \"objectType\": \"user_agent\", \"content\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36\" }, { \"objectType\": \"age\", \"content\": \"65\" }, { \"objectType\": \"search_gender\", \"content\": \"a,b\" }, { \"objectType\": \"avatar\", \"content\": \"http://img.example.com/m/avatar/19/1/f6/3/71-B833EE35D296C9BE_300_sq.jpg\" }, { \"objectType\": \"region\", \"content\": \"Berlin\" }, { \"objectType\": \"user_agent_platform\", \"content\": \"linux\" }, { \"objectType\": \"user_agent\", \"content\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36\" }, { \"objectType\": \"user_agent_browser\", \"content\": \"chrome\" }, { \"objectType\": \"user_agent_language\", \"content\": \"\" }, { \"objectType\": \"user_agent_version\", \"content\": \"63.0.3239.108\" }], \"displayName\": \"Um9iYnk=\", \"content\": \"<session UUID>\" }, \"provider\": { \"id\": \"wioenv\" }, \"verb\": \"login\", \"published\": \"2018-09-17T05:25:38Z\" }","title":"User successfully logged in"},{"location":"md/external_events/#a-user-was-reported-for-a-message-heshe-sent","text":"A message may be reported in the front-end, and a report will be published to the MQ. The event looks like this: { \"actor\": { \"id\": \"<user ID that reported the message>\", \"displayName\": \"<the user name who reported the message>\" }, \"object\": { \"id\": \"<uuid of message>\", \"content\": \"<the actual message to report, base64>\", \"summary\": \"<optional reason text, base64>\" }, \"target\": { \"id\": \"<user ID to report>\", \"displayName\": \"<the user name of the reported user>\" }, \"verb\": \"report\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" }","title":"A user was reported for a message he/she sent"},{"location":"md/external_events/#user-disconnected","text":"Example of activity when a user disconnects: { \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<base64 encoded username>\" }, \"verb\": \"disconnect\", \"id\": \"<server-generated UUID>\", \"published\": \"<server-generated timestamp, RFC3339 format>\" }","title":"User disconnected"},{"location":"md/external_events/#user-becomes-invisible","text":"When a user changes the status to become invisible the following event is published to the external queue: { \"id\": \"<server-generated UUID>\", \"actor\": { \"id\": \"635328\", \"displayName\": \"amtia2prYmJrag==\" }, \"verb\": \"invisible\", \"published\": \"<server-generated timestamp, RFC3339 format>\" }","title":"User becomes invisible"},{"location":"md/external_events/#user-becomes-visible-after-being-in-visible","text":"When a user changes his status to become visible again after being invisible the following event is sent to the external queue: { \"id\": \"<server-generated UUID>\", \"actor\": { \"id\": \"635328\", \"displayName\": \"amtia2prYmJrag==\" }, \"verb\": \"online\", \"published\": \"<server-generated timestamp, RFC3339 format>\" }","title":"User becomes visible after being in visible"},{"location":"md/getting_started/","text":"Quick start This example is using JavaScript. First we connect to the server: socket = io.connect( 'http://' + document.domain + ':' + location.port + '/chat', {transports:['websocket']} ); We'll receive a connect event back after successfully connecting. Now we have to send the login event to provide the server with some extra user information and to do authentication: socket.on('connect', function() { socket.emit('login', { verb: 'login', actor: { id: '<user ID>', attachments: [ { objectType: 'token', content: '<auth token>' } ] } }); }); All events sent to the server will get a response with the same name plus a prefix of gn_ . For example, the login event sent above will get the following response, gn_login , meaning we've successfully authenticated with the server. Now we can start joining rooms, chatting, sending events etc. socket.on('gn_login', function(response) { socket.emit('list_channels', { verb: 'list' }); }); The response from the server will be in JSON format. If no data is expected for the events, only a status code will be in the response. For example, sending the join event to join a room won't return any data, but only the following (if successful): { \"status_code\": 200 } Failure to execute an event on the server will return an error code : { \"status_code\": 423, \"data\": \"<an error message, always a string>\" } If an internal server error occurs, code 500 is returned: { \"status_code\": 500, \"data\": \"<an error message, always a string>\" } The format of the response can be configured, e.g. to return key \"error\" for error messages and use \"data\" only for json data. For events that contains data in the response, for example when sending the event list_channels , we expect to get a list of channels in the response. For these events the data part is always a JSON in the ActivityStreams 1.0 format: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"channels\" \"attachments\": [ { \"id\": \"<channel ID 1>\", \"content\": \"<channel name 1 in base64>\" }, { \"id\": \"<channel ID 2>\", \"content\": \"<channel name 2 in base64>\" }, { \"id\": \"<channel ID 3>\", \"content\": \"<channel name 3 in base64>\" } ] }, \"verb\": \"list\" } } Encoding All user names, room names, channel names and chat messages are expected to be base64 encoded unicode strings. All responses and events originating from the server will also follow this practice, so when listing rooms/channels/users all names will always be in base64. Authentication If the redis authentication method is configured, then when clients send the login event to the server, the supplied token and actor.id parameter must already exist in Redis. When the server gets the login event it will check if the token matches the one stored in Redis for this user ID, otherwise it will not authenticate the session. Therefor, before a client can login, these two values (and any other possible values used for permissions) needs to first be set in the Redis hset with key user:auth:<user ID> . Example: $ redis-cli 127.0.0.1:6379> hset user:auth:1234 token 302fe6be-a72f-11e6-b5fc-330653beb4be 127.0.0.1:6379> hset user:auth:1234 age 35 127.0.0.1:6379> hset user:auth:1234 gender m Private messaging Sometimes private messaging should be identified by the unique combination of two user IDs, say 1 and 2 , so that the history between them can be accesses by both parties. In this case, the client implementation should generate an identifiable \"name\" for this combination, and create a room to group these messages in. For example, the implementer generates a thread_id or conversation_id on their side, then call the create API with the name set as this generated ID. For example, if the ID 42 is generated for the conversation assiciated with the users 1 and 2 : socket.emit('create', { verb: 'create' object: { url: '<channel uuid>' }, target: { displayName: '42', objectType: 'private', attachments: [{ objectType: 'owners', summary: '1,2' }] } }, function(status_code, data, error_msg) { // callback method, check create api for format of the data param }); The callback method will contain the generated UUID of this room (e,g, 4b90eae8-c82b-11e7-98ba-43d525dbbb29 ), which should be used when joining, sending message etc. It is the responsibility of the implementer to keep track of the room IDs associated with conversations. All users specied as the \"owners\" will receive the gn_room_created event if they are online, otherwise they would get it as history later. To send a message in this room , first join the room (will return the history of this room): socket.emit('join', { verb: 'join', target: { id: '4b90eae8-c82b-11e7-98ba-43d525dbbb29' } }, function(status_code, data, error_msg) { // callback method }); Alternatively, a room can be joined by the display_name instead of by id , in case that the UUID is not known on the client side a the time of joining. If multiple rooms exists with the same display_name , the join event will fail with the error code 715 , though in reality that should not happen unless the uniqueness of room names per channel during creation has been disabled. Example of joining using display_name : socket.emit('join', { verb: 'join', target: { display_name: '42' } }, function(status_code, data, error_msg) { // callback method, generated room uuid is data.target.id }); Use the message API to send a message to this room: socket.emit('message', { verb: 'send', target: { id: '4b90eae8-c82b-11e7-98ba-43d525dbbb29', }, object: { content: '<the message, base64 encoded>', } }, function(status_code, data, error_msg) { // callback method }); If the other user is online, he/she will get the message received event. Java client Using the Java socket.io library , you have to use http instead of ws and https instead of wss (it's the same thing). Create your object and use Gson to serialize it to json for a JSONObject (you cannot do a toString of the obejct, it needs to be a json object): Gson gson = new Gson(); try { JSONObject obj = new JSONObject(gson.toJson(o)); s.emit(\"login\", obj); } catch (JSONException e) { e.printStackTrace(); } Delivery acknowledgment All APIs will invoke the callback (if specified) with a status_code and possibly error_message (if any errors). These should be be retrieved in the callback defined on the client side. If there was no error, the second argument will be nil. Examples of callbacks on client side in JavaScript: socket.emit('message', '<omitted json message>', function(status_code, error_msg) { // do something }); Messages should also be awknowledged by the client when received . An awknowledgement can also be sent by the client when a messages as been read , to let other clients know if the message has been seen or not. Unawknowledged (no received ack sent by client) messages will in future version be redelivered since it might indicate a loss during transmission. Example of sending acknowledgement of received message as well as listening for the OK server response to the ack: socket.on('gn_message', function(response) { if (response.status_code !== 200) { // handle error some way return; } // acknowledge that we got the message socket.emit('received', { verb: 'receive', target: { id: room_id }, object: { attachments: [{ // response.data.id is the generated uuid of the message, see api docs id: response.data.id }] } }, function(status_code, error_msg) { // server \"acks our ack\" console.log('callback for received api: ' + status_code) }); // finally handle the message handle_message(data); }); Limited sessions The session handler can be configured to either allow only one simultaneous connection per user or an unlimited amount. If only one session is allowed, then whenever a new session by the same user is started, the previous connection will be disconnected.","title":"Getting Started"},{"location":"md/getting_started/#quick-start","text":"This example is using JavaScript. First we connect to the server: socket = io.connect( 'http://' + document.domain + ':' + location.port + '/chat', {transports:['websocket']} ); We'll receive a connect event back after successfully connecting. Now we have to send the login event to provide the server with some extra user information and to do authentication: socket.on('connect', function() { socket.emit('login', { verb: 'login', actor: { id: '<user ID>', attachments: [ { objectType: 'token', content: '<auth token>' } ] } }); }); All events sent to the server will get a response with the same name plus a prefix of gn_ . For example, the login event sent above will get the following response, gn_login , meaning we've successfully authenticated with the server. Now we can start joining rooms, chatting, sending events etc. socket.on('gn_login', function(response) { socket.emit('list_channels', { verb: 'list' }); }); The response from the server will be in JSON format. If no data is expected for the events, only a status code will be in the response. For example, sending the join event to join a room won't return any data, but only the following (if successful): { \"status_code\": 200 } Failure to execute an event on the server will return an error code : { \"status_code\": 423, \"data\": \"<an error message, always a string>\" } If an internal server error occurs, code 500 is returned: { \"status_code\": 500, \"data\": \"<an error message, always a string>\" } The format of the response can be configured, e.g. to return key \"error\" for error messages and use \"data\" only for json data. For events that contains data in the response, for example when sending the event list_channels , we expect to get a list of channels in the response. For these events the data part is always a JSON in the ActivityStreams 1.0 format: { \"status_code\": 200, \"data\": { \"object\": { \"objectType\": \"channels\" \"attachments\": [ { \"id\": \"<channel ID 1>\", \"content\": \"<channel name 1 in base64>\" }, { \"id\": \"<channel ID 2>\", \"content\": \"<channel name 2 in base64>\" }, { \"id\": \"<channel ID 3>\", \"content\": \"<channel name 3 in base64>\" } ] }, \"verb\": \"list\" } }","title":"Quick start"},{"location":"md/getting_started/#encoding","text":"All user names, room names, channel names and chat messages are expected to be base64 encoded unicode strings. All responses and events originating from the server will also follow this practice, so when listing rooms/channels/users all names will always be in base64.","title":"Encoding"},{"location":"md/getting_started/#authentication","text":"If the redis authentication method is configured, then when clients send the login event to the server, the supplied token and actor.id parameter must already exist in Redis. When the server gets the login event it will check if the token matches the one stored in Redis for this user ID, otherwise it will not authenticate the session. Therefor, before a client can login, these two values (and any other possible values used for permissions) needs to first be set in the Redis hset with key user:auth:<user ID> . Example: $ redis-cli 127.0.0.1:6379> hset user:auth:1234 token 302fe6be-a72f-11e6-b5fc-330653beb4be 127.0.0.1:6379> hset user:auth:1234 age 35 127.0.0.1:6379> hset user:auth:1234 gender m","title":"Authentication"},{"location":"md/getting_started/#private-messaging","text":"Sometimes private messaging should be identified by the unique combination of two user IDs, say 1 and 2 , so that the history between them can be accesses by both parties. In this case, the client implementation should generate an identifiable \"name\" for this combination, and create a room to group these messages in. For example, the implementer generates a thread_id or conversation_id on their side, then call the create API with the name set as this generated ID. For example, if the ID 42 is generated for the conversation assiciated with the users 1 and 2 : socket.emit('create', { verb: 'create' object: { url: '<channel uuid>' }, target: { displayName: '42', objectType: 'private', attachments: [{ objectType: 'owners', summary: '1,2' }] } }, function(status_code, data, error_msg) { // callback method, check create api for format of the data param }); The callback method will contain the generated UUID of this room (e,g, 4b90eae8-c82b-11e7-98ba-43d525dbbb29 ), which should be used when joining, sending message etc. It is the responsibility of the implementer to keep track of the room IDs associated with conversations. All users specied as the \"owners\" will receive the gn_room_created event if they are online, otherwise they would get it as history later. To send a message in this room , first join the room (will return the history of this room): socket.emit('join', { verb: 'join', target: { id: '4b90eae8-c82b-11e7-98ba-43d525dbbb29' } }, function(status_code, data, error_msg) { // callback method }); Alternatively, a room can be joined by the display_name instead of by id , in case that the UUID is not known on the client side a the time of joining. If multiple rooms exists with the same display_name , the join event will fail with the error code 715 , though in reality that should not happen unless the uniqueness of room names per channel during creation has been disabled. Example of joining using display_name : socket.emit('join', { verb: 'join', target: { display_name: '42' } }, function(status_code, data, error_msg) { // callback method, generated room uuid is data.target.id }); Use the message API to send a message to this room: socket.emit('message', { verb: 'send', target: { id: '4b90eae8-c82b-11e7-98ba-43d525dbbb29', }, object: { content: '<the message, base64 encoded>', } }, function(status_code, data, error_msg) { // callback method }); If the other user is online, he/she will get the message received event.","title":"Private messaging"},{"location":"md/getting_started/#java-client","text":"Using the Java socket.io library , you have to use http instead of ws and https instead of wss (it's the same thing). Create your object and use Gson to serialize it to json for a JSONObject (you cannot do a toString of the obejct, it needs to be a json object): Gson gson = new Gson(); try { JSONObject obj = new JSONObject(gson.toJson(o)); s.emit(\"login\", obj); } catch (JSONException e) { e.printStackTrace(); }","title":"Java client"},{"location":"md/getting_started/#delivery-acknowledgment","text":"All APIs will invoke the callback (if specified) with a status_code and possibly error_message (if any errors). These should be be retrieved in the callback defined on the client side. If there was no error, the second argument will be nil. Examples of callbacks on client side in JavaScript: socket.emit('message', '<omitted json message>', function(status_code, error_msg) { // do something }); Messages should also be awknowledged by the client when received . An awknowledgement can also be sent by the client when a messages as been read , to let other clients know if the message has been seen or not. Unawknowledged (no received ack sent by client) messages will in future version be redelivered since it might indicate a loss during transmission. Example of sending acknowledgement of received message as well as listening for the OK server response to the ack: socket.on('gn_message', function(response) { if (response.status_code !== 200) { // handle error some way return; } // acknowledge that we got the message socket.emit('received', { verb: 'receive', target: { id: room_id }, object: { attachments: [{ // response.data.id is the generated uuid of the message, see api docs id: response.data.id }] } }, function(status_code, error_msg) { // server \"acks our ack\" console.log('callback for received api: ' + status_code) }); // finally handle the message handle_message(data); });","title":"Delivery acknowledgment"},{"location":"md/getting_started/#limited-sessions","text":"The session handler can be configured to either allow only one simultaneous connection per user or an unlimited amount. If only one session is allowed, then whenever a new session by the same user is started, the previous connection will be disconnected.","title":"Limited sessions"},{"location":"md/installation/","text":"Requirements Some package requirements (debian/ubuntu): $ sudo apt-get update $ sudo apt-get install tar git curl nano wget dialog net-tools build-essential $ sudo apt-get install libssl-dev libmysqlclient-dev libpq-dev virtualenv From source Requires Python >=3.5.0. Download and install from source (tip: install in /opt since it might interfere with other python installations, present or future): $ wget https://www.python.org/ftp/python/3.5.4/Python-3.5.4.tar.xz $ tar -xvf Python-3.5.4.tar.xz $ cd Python-3.5.4/ $ sudo mkdir /opt/python-3.5.4 $ ./configure --prefix=/opt/python-3.5.4 --enable-shared LDFLAGS=\"-Wl,-rpath /usr/local/lib\" --enable-optimizations $ make $ sudo make altinstall Add the paths to your .bashrc or .profile : export PATH=\"/opt/python-3.5.4/bin/:$PATH\" export LD_LIBRARY_PATH=\"/opt/python-3.5.4/lib/:$LD_LIBRARY_PATH\" Install requirements: $ source env/bin/activate (env) $ pip install -r requirements.txt Using MiniConda Install miniconda : $ wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh $ bash Miniconda3-latest-Linux-x86_64.sh # assuming defaults accepted $ source ~/.bashrc Create your environment and install the requirements: $ conda create -n env python=3.5 $ source activate env $ pip install -r requirements.txt Other requirements If you're using redis, postgresql/mysql and/or cassandra, please see relevant documentation for how to install: Redis PostgreSQL MySQL Apache Cassandra Installing There are a few choices included for how to install Dino. Simple Just clone and run from the cloned directory: $ git clone https://github.com/thenetcircle/dino.git $ cd dino $ virtualenv --python=python3.5 env $ source env/bin/activate (env) $ pip install --upgrade -r requirements.txt (env) $ pip install --upgrade --no-deps . Using init script $ git clone https://github.com/thenetcircle/dino.git foobar-prod $ cd foobar-prod $ virtualenv --python=python3.5 env $ sudo cp bin/initd/dino-app /etc/init.d/ $ source env/bin/activate (env) $ pip install --upgrade -r requirements.txt (env) $ pip install --upgrade --no-deps . Make sure to update the init script to use the correct paths. Using the supplied install script The install script will copy the systemd files to /usr/lib/systemd/system/ , one for each service/environment you install for. $ pwd /home/dino $ git clone https://github.com/thenetcircle/dino.git foobar-prod $ cd foobar-prod $ virtualenv --python=python3.5 env $ sudo ./bin/install.sh foobar-prod /home/dino/foobar-prod app 5200 $ sudo ./bin/install.sh foobar-prod /home/dino/foobar-prod rest 5400 $ sudo ./bin/install.sh foobar-prod /home/dino/foobar-prod web 5300 $ source env/bin/activate (env) $ pip install --upgrade -r requirements.txt (env) $ pip install --upgrade --no-deps . Clustering If clustering dino, install a reverse proxy that supports websockets, e.g. nginx (>= 1.4). Here's an example configuration: upstream gridnodes { ip_hash; server some-ip-or-host-1:5210; server some-ip-or-host-2:5210; server some-ip-or-host-3:5210; server some-ip-or-host-4:5210; server some-ip-or-host-5:5210; server some-ip-or-host-6:5210; server some-ip-or-host-7:5210; server some-ip-or-host-8:5210; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 5200; location / { access_log on; proxy_pass http://gridnodes; proxy_next_upstream error timeout invalid_header http_500; proxy_connect_timeout 2; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # WebSocket support (nginx 1.4) proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } } Running the application A few examples are included for running Dino: running in the foreground, using systemd and the deploy script, docker and lastly kubernetes. Simple Running in the foreground: $ cd dino/ $ virtualenv --python=python3.5 env $ source env/bin/activate (env) $ DINO_ENVIRONMENT=dev gunicorn \\ --error-logfile ~/dino-gunicorn-error.log \\ --log-file ~/dino-gunicorn.log \\ --worker-class eventlet \\ --threads 1 \\ --worker-connections 5000 \\ --workers 1 \\ --bind 0.0.0.0:5210 \\ app:app To run the rest API and admin interface use the same command but change app:app to rest:app and web:app respectively. Using the deploy script The simple deployment script included pulls from git master, shuts down services, clears online tables then starts everything up again. The script assumes the base directory where the project is checked out has the same name as the environment . The deployment script also assumes you're running with systemd and have used the installation script to first install Dino. The deployment script will deploy for all services that are installed for the environment, so if you've only installed the app and rest service but not the web service, then only the app and rest service will be re-deployed. So if you're environment is called foobar-prod : $ cd /home/dino/foobar-prod $ DINO_ENVIRONMENT=foobar-prod DINO_HOME=/home/dino/foobar-prod ./bin/deploy-simple.sh starting deployment... pulling from git... Already up-to-date. stopping web... stopping rest... stopping app... clearing online cache... clearing online db tables... starting app... starting rest... starting web... deployment done! Running in Docker First create the image: sudo docker build -t dino . Then we can run it (create an environments file in secrets/ for your chosen environment (dev/prod/etc), e.g. secrets/dev.env . Check the secrets/default.env for an example. Then we can run the image: sudo docker run --env-file=secrets/dev.env --env DINO_PORT=5120 -t dino Note that we didn't put the port in the dev.env file (though we could), because if starting multiple dino nodes they need to use different ports. Running in Kubernetes For running in Kubernetes we need to use Kubernetes Secrets instead of the .env files. Example configuration for some secret values for your pod: apiVersion: v1 kind: Pod metadata: name: secret-env-pod spec: containers: - name: mycontainer image: redis env: - name: DINO_DB_HOST valueFrom: secretKeyRef: name: dev-secrets key: db-host - name: DINO_DB_USER valueFrom: secretKeyRef: name: dev-secrets key: db-user restartPolicy: Never Read more on Kubernetes website on how to create the secrets object and then how to configure your pod to use it . Monitoring Dino can be extensively monitored by configuring a statsd endpoint. In dino.yaml you can either choose mock to disable metrics: stats: type: 'statsd' host: 'mock' Or choose statsd with a host and port to publish all metrics to a statsd host, for example like this: stats: type: 'statsd' host: '$DINO_STATSD_HOST' port: 8125 prefix: 'dino.myapp' include_hostname: 'true' If you choose true for include_hostname (good when running multiple nodes on different physical machines, in this example it's skybox-04 ) then the value of import socket; socket.gethostname() will be added after the value supplied for prefix . So in the example above, when the mean timer value of the metric for how long time the api action on_login takes would be: dino.myapp.skybox-04.event.on_login.timer.mean An already configured solution for statsd with influxdb and the grafana frontend exists with the following docker image : docker run -d \\ --name grafana \\ -p 3003:9000 \\ -p 3004:8083 \\ -p 8086:8086 \\ -p 22022:22 \\ -p 8125:8125/udp \\ advantageous/grafana:latest:latest And configure the statsd host to the IP you run the docker image on, and the port 8125 . Example of enabling this statsd host with this docker image running: Building the documentation Viewing locally: $ mkdocs serve Building the site (not necessary): $ mkdocs build Deploy to gihub pages: $ mkdocs gh-deploy","title":"Installation"},{"location":"md/installation/#requirements","text":"Some package requirements (debian/ubuntu): $ sudo apt-get update $ sudo apt-get install tar git curl nano wget dialog net-tools build-essential $ sudo apt-get install libssl-dev libmysqlclient-dev libpq-dev virtualenv","title":"Requirements"},{"location":"md/installation/#from-source","text":"Requires Python >=3.5.0. Download and install from source (tip: install in /opt since it might interfere with other python installations, present or future): $ wget https://www.python.org/ftp/python/3.5.4/Python-3.5.4.tar.xz $ tar -xvf Python-3.5.4.tar.xz $ cd Python-3.5.4/ $ sudo mkdir /opt/python-3.5.4 $ ./configure --prefix=/opt/python-3.5.4 --enable-shared LDFLAGS=\"-Wl,-rpath /usr/local/lib\" --enable-optimizations $ make $ sudo make altinstall Add the paths to your .bashrc or .profile : export PATH=\"/opt/python-3.5.4/bin/:$PATH\" export LD_LIBRARY_PATH=\"/opt/python-3.5.4/lib/:$LD_LIBRARY_PATH\" Install requirements: $ source env/bin/activate (env) $ pip install -r requirements.txt","title":"From source"},{"location":"md/installation/#using-miniconda","text":"Install miniconda : $ wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh $ bash Miniconda3-latest-Linux-x86_64.sh # assuming defaults accepted $ source ~/.bashrc Create your environment and install the requirements: $ conda create -n env python=3.5 $ source activate env $ pip install -r requirements.txt","title":"Using MiniConda"},{"location":"md/installation/#other-requirements","text":"If you're using redis, postgresql/mysql and/or cassandra, please see relevant documentation for how to install: Redis PostgreSQL MySQL Apache Cassandra","title":"Other requirements"},{"location":"md/installation/#installing","text":"There are a few choices included for how to install Dino.","title":"Installing"},{"location":"md/installation/#simple","text":"Just clone and run from the cloned directory: $ git clone https://github.com/thenetcircle/dino.git $ cd dino $ virtualenv --python=python3.5 env $ source env/bin/activate (env) $ pip install --upgrade -r requirements.txt (env) $ pip install --upgrade --no-deps .","title":"Simple"},{"location":"md/installation/#using-init-script","text":"$ git clone https://github.com/thenetcircle/dino.git foobar-prod $ cd foobar-prod $ virtualenv --python=python3.5 env $ sudo cp bin/initd/dino-app /etc/init.d/ $ source env/bin/activate (env) $ pip install --upgrade -r requirements.txt (env) $ pip install --upgrade --no-deps . Make sure to update the init script to use the correct paths.","title":"Using init script"},{"location":"md/installation/#using-the-supplied-install-script","text":"The install script will copy the systemd files to /usr/lib/systemd/system/ , one for each service/environment you install for. $ pwd /home/dino $ git clone https://github.com/thenetcircle/dino.git foobar-prod $ cd foobar-prod $ virtualenv --python=python3.5 env $ sudo ./bin/install.sh foobar-prod /home/dino/foobar-prod app 5200 $ sudo ./bin/install.sh foobar-prod /home/dino/foobar-prod rest 5400 $ sudo ./bin/install.sh foobar-prod /home/dino/foobar-prod web 5300 $ source env/bin/activate (env) $ pip install --upgrade -r requirements.txt (env) $ pip install --upgrade --no-deps .","title":"Using the supplied install script"},{"location":"md/installation/#clustering","text":"If clustering dino, install a reverse proxy that supports websockets, e.g. nginx (>= 1.4). Here's an example configuration: upstream gridnodes { ip_hash; server some-ip-or-host-1:5210; server some-ip-or-host-2:5210; server some-ip-or-host-3:5210; server some-ip-or-host-4:5210; server some-ip-or-host-5:5210; server some-ip-or-host-6:5210; server some-ip-or-host-7:5210; server some-ip-or-host-8:5210; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 5200; location / { access_log on; proxy_pass http://gridnodes; proxy_next_upstream error timeout invalid_header http_500; proxy_connect_timeout 2; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # WebSocket support (nginx 1.4) proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } }","title":"Clustering"},{"location":"md/installation/#running-the-application","text":"A few examples are included for running Dino: running in the foreground, using systemd and the deploy script, docker and lastly kubernetes.","title":"Running the application"},{"location":"md/installation/#simple_1","text":"Running in the foreground: $ cd dino/ $ virtualenv --python=python3.5 env $ source env/bin/activate (env) $ DINO_ENVIRONMENT=dev gunicorn \\ --error-logfile ~/dino-gunicorn-error.log \\ --log-file ~/dino-gunicorn.log \\ --worker-class eventlet \\ --threads 1 \\ --worker-connections 5000 \\ --workers 1 \\ --bind 0.0.0.0:5210 \\ app:app To run the rest API and admin interface use the same command but change app:app to rest:app and web:app respectively.","title":"Simple"},{"location":"md/installation/#using-the-deploy-script","text":"The simple deployment script included pulls from git master, shuts down services, clears online tables then starts everything up again. The script assumes the base directory where the project is checked out has the same name as the environment . The deployment script also assumes you're running with systemd and have used the installation script to first install Dino. The deployment script will deploy for all services that are installed for the environment, so if you've only installed the app and rest service but not the web service, then only the app and rest service will be re-deployed. So if you're environment is called foobar-prod : $ cd /home/dino/foobar-prod $ DINO_ENVIRONMENT=foobar-prod DINO_HOME=/home/dino/foobar-prod ./bin/deploy-simple.sh starting deployment... pulling from git... Already up-to-date. stopping web... stopping rest... stopping app... clearing online cache... clearing online db tables... starting app... starting rest... starting web... deployment done!","title":"Using the deploy script"},{"location":"md/installation/#running-in-docker","text":"First create the image: sudo docker build -t dino . Then we can run it (create an environments file in secrets/ for your chosen environment (dev/prod/etc), e.g. secrets/dev.env . Check the secrets/default.env for an example. Then we can run the image: sudo docker run --env-file=secrets/dev.env --env DINO_PORT=5120 -t dino Note that we didn't put the port in the dev.env file (though we could), because if starting multiple dino nodes they need to use different ports.","title":"Running in Docker"},{"location":"md/installation/#running-in-kubernetes","text":"For running in Kubernetes we need to use Kubernetes Secrets instead of the .env files. Example configuration for some secret values for your pod: apiVersion: v1 kind: Pod metadata: name: secret-env-pod spec: containers: - name: mycontainer image: redis env: - name: DINO_DB_HOST valueFrom: secretKeyRef: name: dev-secrets key: db-host - name: DINO_DB_USER valueFrom: secretKeyRef: name: dev-secrets key: db-user restartPolicy: Never Read more on Kubernetes website on how to create the secrets object and then how to configure your pod to use it .","title":"Running in Kubernetes"},{"location":"md/installation/#monitoring","text":"Dino can be extensively monitored by configuring a statsd endpoint. In dino.yaml you can either choose mock to disable metrics: stats: type: 'statsd' host: 'mock' Or choose statsd with a host and port to publish all metrics to a statsd host, for example like this: stats: type: 'statsd' host: '$DINO_STATSD_HOST' port: 8125 prefix: 'dino.myapp' include_hostname: 'true' If you choose true for include_hostname (good when running multiple nodes on different physical machines, in this example it's skybox-04 ) then the value of import socket; socket.gethostname() will be added after the value supplied for prefix . So in the example above, when the mean timer value of the metric for how long time the api action on_login takes would be: dino.myapp.skybox-04.event.on_login.timer.mean An already configured solution for statsd with influxdb and the grafana frontend exists with the following docker image : docker run -d \\ --name grafana \\ -p 3003:9000 \\ -p 3004:8083 \\ -p 8086:8086 \\ -p 22022:22 \\ -p 8125:8125/udp \\ advantageous/grafana:latest:latest And configure the statsd host to the IP you run the docker image on, and the port 8125 . Example of enabling this statsd host with this docker image running:","title":"Monitoring"},{"location":"md/installation/#building-the-documentation","text":"Viewing locally: $ mkdocs serve Building the site (not necessary): $ mkdocs build Deploy to gihub pages: $ mkdocs gh-deploy","title":"Building the documentation"},{"location":"md/invisibility/","text":"Invisibility There are multiple ways to change visibility status, either explicitly using the status api, or implicitly using the login api: REST API /status , WS API status , WS API login . When doing an invisible login, the last_online_at should not be updated, and the user status in the cache should be 3 (invisible, see the WIO docs for more info). There are however ways to force a different behavior; see below. Using the REST api for invisible login To do an invisible login, you can either call the REST API /status first (before login), with the stage parameter set to login (instead of the default status ), then call this WS API normally to login (without actor.summary: 'login' ). The user will then be invisible before he/she logs in, and the last_online_at will not be updated. The REST api request would look as follows: { \"id\": \"<user ID>\", \"status\": \"invisible\", \"stage\": \"login\" } Note: if stage is set to status instead of login , then last_online_at will be updated. Next, the WS login request would look as follows: { \"verb\": \"login\", \"actor\": { \"id\": \"5666\", \"displayName\": \"Zm9vYmFy\", \"attachments\": [{ \"objectType\": \"token\", \"content\": \"some-token\" }] } } Now the user has logged in invisibly. Note: There's no need for actor.summary: 'login' here, since we already set the user to invisibly using the rest API before the user logged in. Note: There's no need to call the WS status API now, the user is already invisible. Using the WS api for invisible login The other option is to set actor.content to invisible in the WS login request, in which case there's no need to call the REST api. The REST api approach is preferred though, since only paying users should be allowed to be invisible, so by using the REST api, the community backend can check the membership status before setting a user invisible. When using the WS api for this, there's no validation if the user is allowed to be invisible or not, and a user could alter the request on client side to circumvent the restriction. Invisible login using the WS login api looks are follows: { \"verb\": \"login\", \"actor\": { \"id\": \"5666\", \"displayName\": \"Zm9vYmFy\", \"content\": \"invisible\", \"attachments\": [{ \"objectType\": \"token\", \"content\": \"some-token\" }] } } Now the user has logged in invisibly. Note: There's no need to call the WS status API now, the user is already invisible. Changing status to invisible while online When a user is online, and wants to change his/her status to invisible , the WS api status can be used. The request looks as follows: { \"verb\": \"invisible\" } The user will not become invisible, and the last_online_at will be updated to this time. A fake gn_user_disconnected event will be sent to relevant users. Note: If the request contains actor.summary: \"login\" , then last_online_at will be updated. Thus, when a user is already online, don't set the summary to login ; you can leave it out of the request.","title":"Invisibility"},{"location":"md/invisibility/#invisibility","text":"There are multiple ways to change visibility status, either explicitly using the status api, or implicitly using the login api: REST API /status , WS API status , WS API login . When doing an invisible login, the last_online_at should not be updated, and the user status in the cache should be 3 (invisible, see the WIO docs for more info). There are however ways to force a different behavior; see below.","title":"Invisibility"},{"location":"md/invisibility/#using-the-rest-api-for-invisible-login","text":"To do an invisible login, you can either call the REST API /status first (before login), with the stage parameter set to login (instead of the default status ), then call this WS API normally to login (without actor.summary: 'login' ). The user will then be invisible before he/she logs in, and the last_online_at will not be updated. The REST api request would look as follows: { \"id\": \"<user ID>\", \"status\": \"invisible\", \"stage\": \"login\" } Note: if stage is set to status instead of login , then last_online_at will be updated. Next, the WS login request would look as follows: { \"verb\": \"login\", \"actor\": { \"id\": \"5666\", \"displayName\": \"Zm9vYmFy\", \"attachments\": [{ \"objectType\": \"token\", \"content\": \"some-token\" }] } } Now the user has logged in invisibly. Note: There's no need for actor.summary: 'login' here, since we already set the user to invisibly using the rest API before the user logged in. Note: There's no need to call the WS status API now, the user is already invisible.","title":"Using the REST api for invisible login"},{"location":"md/invisibility/#using-the-ws-api-for-invisible-login","text":"The other option is to set actor.content to invisible in the WS login request, in which case there's no need to call the REST api. The REST api approach is preferred though, since only paying users should be allowed to be invisible, so by using the REST api, the community backend can check the membership status before setting a user invisible. When using the WS api for this, there's no validation if the user is allowed to be invisible or not, and a user could alter the request on client side to circumvent the restriction. Invisible login using the WS login api looks are follows: { \"verb\": \"login\", \"actor\": { \"id\": \"5666\", \"displayName\": \"Zm9vYmFy\", \"content\": \"invisible\", \"attachments\": [{ \"objectType\": \"token\", \"content\": \"some-token\" }] } } Now the user has logged in invisibly. Note: There's no need to call the WS status API now, the user is already invisible.","title":"Using the WS api for invisible login"},{"location":"md/invisibility/#changing-status-to-invisible-while-online","text":"When a user is online, and wants to change his/her status to invisible , the WS api status can be used. The request looks as follows: { \"verb\": \"invisible\" } The user will not become invisible, and the last_online_at will be updated to this time. A fake gn_user_disconnected event will be sent to relevant users. Note: If the request contains actor.summary: \"login\" , then last_online_at will be updated. Thus, when a user is already online, don't set the summary to login ; you can leave it out of the request.","title":"Changing status to invisible while online"},{"location":"md/rest/","text":"GET /acl Retrieve all ACLs for all non-temporary rooms in all channels. Example response: { \"data\": { \"status\": \"OK\", \"data\": { \"0efd8a52-7220-4160-88fe-68a15d470d95\": [{ \"type\": \"admin\", \"action\": \"join\", \"value\": \"\" }, { \"type\": \"admin\", \"action\": \"list\", \"value\": \"\" }], \"a81e4726-784a-11e9-bbdd-bbfdfd886868\": [{ \"type\": \"gender\", \"action\": \"autojoin\", \"value\": \"m,f\" }] } }, \"status_code\": 200 } GET /rooms Returns a list of all rooms currently existing. Result is cached for 1 minute and might thus not be always up-to-date. Example response: { \"data\": [{ \"name\": \"default\", \"status\": \"static\", \"id\": \"2e7d537e-bed5-47c5-a7f6-357075759e5d\", \"channel\": \"App and Web\" }, { \"name\": \"default1\", \"status\": \"static\", \"id\": \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\", \"channel\": \"App only\" }, { \"name\": \"default2\", \"status\": \"temporary\", \"id\": \"6418dff0-43fc-469a-8f3b-724d3a5dcecf\", \"channel\": \"Web only\" }], \"status_code\": 200 } GET /rooms-acl Returns a list of all rooms currently existing, that a specific user is allowed to join (if a user is not allowed to list a channel, no rooms from that channel will be included either). Result is cached for 1 minute per user id and might thus not be always up-to-date. Request: { \"user_id\": \"1234\" } Response: { \"data\": [{ \"status\": \"static\", \"room_id\": \"2e7d537e-bed5-47c5-a7f6-357075759e5d\", \"users\": 0, \"room_name\": \"default\", \"channel_id\": \"7e1beff2-3d4f-40cc-baa5-f1fd79cc59c0\", \"channel_name\": \"App and Web\" }, { \"status\": \"static\", \"room_id\": \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\", \"users\": 0, \"room_name\": \"default1\", \"channel_id\": \"9613fbb5-5eaf-41b1-8480-0b364af04b80\", \"channel_name\": \"App only\" }, { \"status\": \"static\", \"room_id\": \"6418dff0-43fc-469a-8f3b-724d3a5dcecf\", \"users\": 0, \"room_name\": \"default2\", \"channel_id\": \"a37a51f0-48ed-43ba-9fcb-750ce7ee3fdb\", \"channel_name\": \"Web only\" }], \"status_code\": 200 } POST /acl Request: { \"room_id\": \"a81e4726-784a-11e9-bbdd-bbfdfd886868\", \"action\": \"autojoin\", \"acl_type\": \"gender\", \"acl_value\": \"age=35,(gender=f|membership=normal)\" } For more examples on the format of the acl_value field, see the ACL section. Response: { \"data\": { \"status\": \"OK\" }, \"status_code\": 200 } GET /history Request contains info on what time slice, target, origin to get history for: { \"from_time\": \"2016-12-26T08:39:54Z\", \"to_time\": \"2016-12-28T08:39:54Z\", \"user_id\": \"124352\", \"room_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" # optional } Response would be something similar to the following: { \"status_code\": 200, \"data\": [{ \"deleted\": false, \"target_name\": \"YmFkIGtpZHo=\", \"target_id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"timestamp\": \"2017-01-26T04:58:33Z\", \"from_user_name\": \"YmF0bWFu\", \"message_id\": \"37db81f2-4e16-4076-b759-8ce1c23a364e\", \"from_user_id\": \"997110\", \"channel_name\": \"U2hhbmdoYWk=\", \"body\": \"aG93IGFyZSB5b3U/\", \"domain\": \"room\", \"channel_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" }, { \"deleted\": false, \"target_name\": \"YmFkIGtpZHo=\", \"target_id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"timestamp\": \"2017-01-26T04:58:31Z\", \"from_user_name\": \"YmF0bWFu\", \"message_id\": \"416d3c60-7197-471c-a706-7dbeca090d11\", \"from_user_id\": \"997110\", \"channel_name\": \"U2hhbmdoYWk=\", \"body\": \"aGVsbG8gdGhlcmU=\", \"domain\": \"room\", \"channel_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" }, { \"deleted\": false, \"target_name\": \"YmFkIGtpZHo=\", \"target_id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"timestamp\": \"2017-01-26T04:58:16Z\", \"from_user_name\": \"YmF0bWFu\", \"message_id\": \"91655457-3712-4c2f-b6f2-c3b0f8be29e5\", \"from_user_id\": \"997110\", \"channel_name\": \"U2hhbmdoYWk=\", \"body\": \"ZmRzYQ==\", \"domain\": \"room\", \"channel_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" }] } If neither from_time nor to_time is specified, the last 7 days will be used as limit, If from_time is specified but no to_time , to_time will be from_time + 7 days , If to_time is specified but no from_time , from_time will be to_time - 7 days , Either user_id or room_id is required (both can be specified at the same time), to_time needs to be after from_time . POST /heartbeat For mobile clients, it is sometimes tricky to maintain a constant connection due to fluctuations in network quality and data loss. To keep a user in an online state without keeping a connection open, the /heartbeat api can be used instead. With regular /heartbeat calls, a user will not be marked as offline until no more heartbeats are being received. Multiple user IDs can be batched together into a single /heartbeat call. Request: [ \"<user ID 1>\", \"<user ID 2>\", \"<user ID n>\" ] Response: { \"data\": { \"status\": \"OK\" }, \"status_code\": 200 } POST /full-history To get all messages sent by a user, call this endpoint with the following data: { \"user_id\": 1971 \"from_time\": \"2016-12-26T08:39:54Z\", # optional (other needed if this one is specified) \"to_time\": \"2016-12-28T08:39:54Z\" # optional (other needed if this one is specified) } Response looks like this: { \"status_code\": 200, \"data\": [{ \"message_id\": \"07bacdd8-42e6-4ace-acee-8d200dd14bfc\", \"from_user_id\": \"1971\", \"from_user_name\": \"Um9k=\", \"target_id\": \"7935a673-da64-4419-818b-e6e0d1864b61\", \"target_name\": \"TG9iYnk=\", \"body\": \"eyJtYXNrIjoiMDAiLCJ6IjE2IiwidGV4dCI6ImkgYW0gaW52aXNpYmxlIn0=\", \"domain\": \"room\", \"channel_id\": \"84ec4b4f-7482-48ba-83a1-9c9b1c470903\", \"channel_name\": \"UGVu\", \"timestamp\": \"2017-05-23T07:32:07Z\", \"deleted\": true }, {...}] } POST /broadcast Broadcasts a message to everyone on the server. Request needs the body and verb keys: { \"body\": \"aGkgdGhlcmU=\", \"verb\": \"broadcast\" } Body needs to be in base64. The verb may be anything, it's up to clients to handle it. POST /blacklist Add a new word to the blacklist. Encode the word in base64 first, then post a request on the following format: { \"word\": \"YmFkd29yZA==\" } Response if OK: { \"status_code\": 200 } DELETE /blacklist Remove a matching word from the blacklist. Encode the word in base64 first, then post a request on the following format: { \"word\": \"YmFkd29yZA==\" } The sent word will be compared lowercase to find matching lowercased word in the blacklist and remove all words with and exact match (when both lowercase). Response if OK: { \"status_code\": 200 } POST /set-admin Set a user as a global moderator. Request contains user ID and the user's name (in case the user doesn't exist): { \"id\": \"1234\", \"name\": \"myuser\" } Response if OK: { \"status_code\": 200 } Or if any errors: { \"data\": \"no name parameter in request\", \"status_code\": 500 } POST /remove-admin Remove global moderator status for a user. Request contains the user's ID only: { \"id\": \"1234\" } Response if OK: { \"status_code\": 200 } Or if any errors: { \"data\": \"no id parameter in request\", \"status_code\": 500 } POST /ban Request contains info on who to ban where. For banning globally: { \"1234\": { \"duration\": \"24h\", \"reason\": \"<optional base64 encoded free-text>\", \"admin_id\": \"<id of user banning (must already exist), or leave empty for default>\", \"type\": \"global\", \"name\": \"<username in base64, optional>\" } } Can also ban multiple users at the same time: { \"<user id>\": { \"duration\": \"24h\", \"type\": \"global\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is banning>\", \"name\": \"<username in base64, optional>\" }, \"<user id>\": { \"duration\": \"10m\", \"target\": \"<channel uuid>\", \"type\": \"channel\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is banning>\" }, \"<user id>\": { \"duration\": \"7d\", \"target\": \"<room uuid>\", \"type\": \"room\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is banning>\" } } The name field must be base64 encoded. The field is also optional and is only used if a ban request is received for a user that doesn't exist on the server, e.g. if the user never logged in before it will not exist. If the name is not specified, and the user has to be created before banning, the user ID will be set as the name (later when the user login the real username will overwrite this). The reason field must be base64 encoded. If the admin_id field is specified it will be used, if not the default ID 0 will be used (the default admin user). Duration is an integer followed by a char for the unit, which can be one of d , h , m , s (days, hours, minutes, seconds). Negative or 0 durations are not allowed. When type is set to global , no target is specified (meaning user is banned from the whole chat server). Response will be something like the following (if failure): { \"status\": \"FAIL\", \"message\": \"missing target id for user id <user id> and request <the request json>\" } The banning is done async so if any of the provided user bans has invalid parameters the response will only tell you the first non-valid parameter and for which user ID. For success the response looks like this: { \"status\": \"OK\" } POST /kick Request contains: { \"<user id>\": { \"target\": \"<room uuid>\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is kicking>\" }, \"<user id>\": { \"target\": \"<room uuid>\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is kicking>\" }, \"<user id>\": { \"target\": \"<room uuid>\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is kicking>\" } } The \"reason\" field must be base64 encoded. If the \"admin_id\" field is specified it will be used, if not the default ID \"0\" will be used. Response will be something like the following: { \"<user id>\": { \"status\": \"OK\" }, \"<user id>\": { \"status\": \"FAIL\", \"message\": \"no such user\" }, \"<user id>\": { \"status\": \"OK\" } } GET /roles Request contains a list of user IDs, e.g.: { \"users\": [ \"124352\", \"5678\" ] } Response would be something similar to the following: { \"data\": { \"124352\": { \"room\": { \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\": [ \"moderator\" ], \"bb0ea500-cd94-11e6-b178-8323deb605bf\": [ \"owner\" ] }, \"channel\": { \"dedf878e-b25d-4713-8058-20c6f0547c59\": [ \"admin\", \"owner\" ] }, \"global\": [ \"superuser\", \"globalmod\" ] }, \"5678\": { \"room\": {}, \"channel\": {}, \"global\": [] } }, \"status_code\": 200 } Possible roles are: global superuser (superuser) global moderator (globalmod) channel owner (owner) channel admin (admin) room owner (owner) room moderator (moderator) The only difference between global superusers and global moderators is that global superusers can also remove static rooms. GET /count-joins Count the cumulative number of joins for a room. Used for counting the number of \"views\" a live stream has had. The count is cached for 8 hours, then fetched from db if requested again. Using curl: curl localhost:7300/count-joins -X GET -H 'Content-Type: application/json' -d @- << EOF { \"room_ids\": [\"2e7d537e-bed5-47c5-a7f6-357075759e5d\"] } EOF Instead of room_ids , we can use room_names (base64 encoded) instead (only works for rooms in the default channel, e.g. created using POST /create ): curl localhost:7300/count-joins -X GET -H 'Content-Type: application/json' -d @- << EOF { \"room_names\": [\"c29tZSByb29tIG5hbWUK\"] } EOF If room IDs were used in the request, the keys in the response will also be room IDs, but if room names were used, the base64 encoded room name will be the key: { \"status_code\": 200, \"data\": { \"2e7d537e-bed5-47c5-a7f6-357075759e5d\": 5, \"0e88aae3-cb2f-457c-b1be-8e882479bd34\": 3290, \"0c289aaf-3c7b-4290-89bb-e1fa27cd2300\": 89 } } GET /users-in-rooms Request contains a list of room IDs, and an optional only_count field (default is false ), e.g.: { \"room_ids\": [ \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\", \"2e7d537e-bed5-47c5-a7f6-357075759e5d\" ], \"only_count\": false } Instead of room IDs, we can specify room names (base64 encoded): { \"room_names\": [ \"c29tZSByb29tIG5hbWUK\" ] } Response would be all visible users in the specified rooms, with their user infos attached ( roles is a comma-separated list of roles, e.g. owner,globalmod ). If room IDs were used in the request, the keys in the response will also be room IDs, but if room names were used, the base64 encoded room name will be the key: { \"data\": { \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\": [{ \"id\": \"898121\", \"info\": { \"membership\": \"MA==\", \"has_webcam\": \"eQ==\", \"age\": \"OTk=\", \"is_streaming\": \"RmFsc2U=\", \"city\": \"U2FzZGY=\", \"fake_checked\": \"eQ==\", \"country\": \"Y24=\", \"gender\": \"bQ==\", \"image\": \"eQ==\" }, \"roles\": \"owner\", \"name\": \"Um9iYnk=\" }], \"2e7d537e-bed5-47c5-a7f6-357075759e5d\": [] }, \"status_code\": 200 } Response if only_count is true : { \"data\": { \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\": 5, \"2e7d537e-bed5-47c5-a7f6-357075759e5d\": 2 }, \"status_code\": 200 } POST /create Creates and joins the room (if specified users are online). Rooms created using this API will always be in the default channel. Example request: { \"user_ids\": [ \"1234\", \"5678\" ], \"room_name\": \"<a room name, in base64>\", \"owner_id\": \"<a user id>\", \"owner_name\": \"<a user name, in base64>\" } Example response: { \"status_code\": 200, \"data\": { \"room_id\": \"01eafcf0-4ab2-48bb-8ff5-833b056d2727\", \"room_name\": \"tr19\", \"channel_id\": \"8d43181a-13e0-4ccc-a64b-ae8e93d36bcd\" } } POST /join Joins the room (if specified users are online). Only works for rooms in the default channel (e.g. rooms created using the POST /create API). If room_id is specified, it will be used, otherwise, the room_name will be used to lookup the correct room in the default channel. Example request: { \"user_ids\": [ \"1234\", \"5678\" ], \"room_id\": \"<optional: a room id>\", \"room_name\": \"<a room name, in base64>\" } Example response: { \"status_code\": 200 } POST /leave Leaves the room (if specified users are online). Only works for rooms in the default channel (e.g. rooms created using the POST /create API). If room_id is specified, it will be used, otherwise, the room_name will be used to lookup the correct room in the default channel. Example request: { \"user_ids\": [ \"1234\", \"5678\" ], \"room_id\": \"<optional: a room id>\", \"room_name\": \"<a room name, in base64>\" } Example response: { \"status_code\": 200 } GET /rooms-for-users Request contains a list of user IDs, e.g.: { \"users\": [ \"1234\", \"5678\" ] } Response would be all rooms each user is currently in (room names and channel names are base64 encoded): { \"1234\": [{ \"room_id\": \"efeca2fe-ba93-11e6-bc9a-4f6f56293063\", \"room_name\": \"b2gsIHNvIHlvdSBhY3R1YWxseSBjaGVja2VkIHdoYXQgaXMgd2FzPw==\", \"channel_id\": \"fb843140-ba93-11e6-b178-97f0297a6d4d\", \"channel_name\": \"dG9tIGlzIGEgZnJlbmNoIG1hZG1hbg==\" }], \"5678\": [{ \"room_id\": \"ca1dc3b4-ba93-11e6-b835-7f1d961023a1\", \"room_name\": \"cmVhZCB1cCBvbiBoeXBlcmxvZ2xvZysr\", \"channel_id\": \"f621fcaa-ba93-11e6-8590-bfe35ff80c03\", \"channel_name\": \"YSByZWRidWxsIGEgZGF5IGtlZXBzIHRoZSBzYW5kbWFuIGF3YXk=\" }] } POST /delete-messages Used to delete ALL messages for a specific user ID. Request body looks like this: { \"id\": \"<user ID>\" } Example response: { \"status_code\": 200, \"data\": { \"success\": 4, \"failed\": 0, \"total\": 4 } } Or if other kinds of failures: { \"status_code\": 500, \"data\": \"<error message, e.g. 'no id parameter in request'>\" } GET /banned No data required in request. Response is all banned users, separated by channel, room and globally. Example response: { \"channels\": {}, \"global\": { \"185626\": { \"name\": \"bHVlbA==\", \"duration\": \"1h\", \"timestamp\": \"2016-12-05T03:50:24Z\" } }, \"rooms\": { \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\": { \"name\": \"Y29vbCBndXlz\", \"users\": { \"101108\": { \"name\": \"bHVlbA==\", \"duration\": \"30m\", \"timestamp\": \"2016-12-05T03:20:24Z\" } } } } } The \"timestamp\" in the response is the UTC timestamp for when the ban will expire. Names or channels, rooms and users are all base64 encoded. The dictionary keys for \"rooms\" are the UUIDs of the rooms, same for channels, while for users it's their user IDs as keys. The bans for \"global\" have no separation by room/channel IDs, and no \"name\" or \"users\" keys. POST /status Set the online status or visibility status of a user. Request contains: { \"id\": \"<user ID>\", \"status\": \"<one of online/offline/invisible/visible>\", \"stage\": \"<one of login/status>\" } Example response: { \"status_code\": 200 } POST /send If target_id is not specified in the request body, but target_name is, Dino will try to send the message to the room with that name, but it only works for rooms that are in the default channel (rooms created using POST /create are always in the default channel). The target_name field (if specified), must be base64 encoded. Request contains: { \"user_id\": \"<user ID>\", \"user_name\": \"<username, in base64>\", \"object_type\": \"<room/private>\", \"target_id\": \"<user ID to send to or UUID of room to send to>\", \"target_name\": \"<the name of the user/room to send to, in base64>\", \"content\": \"<the body to send, in base64>\" } Example response: { \"status_code\": 200 } User/room will get something similar to this in a message event: { \"id\": \"1d805e18-a773-11e8-a65f-8b33c55c9e1b\", \"published\": \"2017-01-26T04:58:31Z\", \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<username, in base64>\" }, \"verb\": \"send\", \"target\": { \"objectType\": \"<room/private>\", \"id\": \"<user ID to send to or UUID of room to send to>\", \"displayName\": \"<the name of the user/room to send to, in base64>\" }, \"object\": { \"content\": \"<the body to send, in base64>\" } }","title":"REST API"},{"location":"md/rest/#get-acl","text":"Retrieve all ACLs for all non-temporary rooms in all channels. Example response: { \"data\": { \"status\": \"OK\", \"data\": { \"0efd8a52-7220-4160-88fe-68a15d470d95\": [{ \"type\": \"admin\", \"action\": \"join\", \"value\": \"\" }, { \"type\": \"admin\", \"action\": \"list\", \"value\": \"\" }], \"a81e4726-784a-11e9-bbdd-bbfdfd886868\": [{ \"type\": \"gender\", \"action\": \"autojoin\", \"value\": \"m,f\" }] } }, \"status_code\": 200 }","title":"GET /acl"},{"location":"md/rest/#get-rooms","text":"Returns a list of all rooms currently existing. Result is cached for 1 minute and might thus not be always up-to-date. Example response: { \"data\": [{ \"name\": \"default\", \"status\": \"static\", \"id\": \"2e7d537e-bed5-47c5-a7f6-357075759e5d\", \"channel\": \"App and Web\" }, { \"name\": \"default1\", \"status\": \"static\", \"id\": \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\", \"channel\": \"App only\" }, { \"name\": \"default2\", \"status\": \"temporary\", \"id\": \"6418dff0-43fc-469a-8f3b-724d3a5dcecf\", \"channel\": \"Web only\" }], \"status_code\": 200 }","title":"GET /rooms"},{"location":"md/rest/#get-rooms-acl","text":"Returns a list of all rooms currently existing, that a specific user is allowed to join (if a user is not allowed to list a channel, no rooms from that channel will be included either). Result is cached for 1 minute per user id and might thus not be always up-to-date. Request: { \"user_id\": \"1234\" } Response: { \"data\": [{ \"status\": \"static\", \"room_id\": \"2e7d537e-bed5-47c5-a7f6-357075759e5d\", \"users\": 0, \"room_name\": \"default\", \"channel_id\": \"7e1beff2-3d4f-40cc-baa5-f1fd79cc59c0\", \"channel_name\": \"App and Web\" }, { \"status\": \"static\", \"room_id\": \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\", \"users\": 0, \"room_name\": \"default1\", \"channel_id\": \"9613fbb5-5eaf-41b1-8480-0b364af04b80\", \"channel_name\": \"App only\" }, { \"status\": \"static\", \"room_id\": \"6418dff0-43fc-469a-8f3b-724d3a5dcecf\", \"users\": 0, \"room_name\": \"default2\", \"channel_id\": \"a37a51f0-48ed-43ba-9fcb-750ce7ee3fdb\", \"channel_name\": \"Web only\" }], \"status_code\": 200 }","title":"GET /rooms-acl"},{"location":"md/rest/#post-acl","text":"Request: { \"room_id\": \"a81e4726-784a-11e9-bbdd-bbfdfd886868\", \"action\": \"autojoin\", \"acl_type\": \"gender\", \"acl_value\": \"age=35,(gender=f|membership=normal)\" } For more examples on the format of the acl_value field, see the ACL section. Response: { \"data\": { \"status\": \"OK\" }, \"status_code\": 200 }","title":"POST /acl"},{"location":"md/rest/#get-history","text":"Request contains info on what time slice, target, origin to get history for: { \"from_time\": \"2016-12-26T08:39:54Z\", \"to_time\": \"2016-12-28T08:39:54Z\", \"user_id\": \"124352\", \"room_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" # optional } Response would be something similar to the following: { \"status_code\": 200, \"data\": [{ \"deleted\": false, \"target_name\": \"YmFkIGtpZHo=\", \"target_id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"timestamp\": \"2017-01-26T04:58:33Z\", \"from_user_name\": \"YmF0bWFu\", \"message_id\": \"37db81f2-4e16-4076-b759-8ce1c23a364e\", \"from_user_id\": \"997110\", \"channel_name\": \"U2hhbmdoYWk=\", \"body\": \"aG93IGFyZSB5b3U/\", \"domain\": \"room\", \"channel_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" }, { \"deleted\": false, \"target_name\": \"YmFkIGtpZHo=\", \"target_id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"timestamp\": \"2017-01-26T04:58:31Z\", \"from_user_name\": \"YmF0bWFu\", \"message_id\": \"416d3c60-7197-471c-a706-7dbeca090d11\", \"from_user_id\": \"997110\", \"channel_name\": \"U2hhbmdoYWk=\", \"body\": \"aGVsbG8gdGhlcmU=\", \"domain\": \"room\", \"channel_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" }, { \"deleted\": false, \"target_name\": \"YmFkIGtpZHo=\", \"target_id\": \"675eb2a5-17c6-45e4-bc0f-674241573f22\", \"timestamp\": \"2017-01-26T04:58:16Z\", \"from_user_name\": \"YmF0bWFu\", \"message_id\": \"91655457-3712-4c2f-b6f2-c3b0f8be29e5\", \"from_user_id\": \"997110\", \"channel_name\": \"U2hhbmdoYWk=\", \"body\": \"ZmRzYQ==\", \"domain\": \"room\", \"channel_id\": \"dedf878e-b25d-4713-8058-20c6f0547c59\" }] } If neither from_time nor to_time is specified, the last 7 days will be used as limit, If from_time is specified but no to_time , to_time will be from_time + 7 days , If to_time is specified but no from_time , from_time will be to_time - 7 days , Either user_id or room_id is required (both can be specified at the same time), to_time needs to be after from_time .","title":"GET /history"},{"location":"md/rest/#post-heartbeat","text":"For mobile clients, it is sometimes tricky to maintain a constant connection due to fluctuations in network quality and data loss. To keep a user in an online state without keeping a connection open, the /heartbeat api can be used instead. With regular /heartbeat calls, a user will not be marked as offline until no more heartbeats are being received. Multiple user IDs can be batched together into a single /heartbeat call. Request: [ \"<user ID 1>\", \"<user ID 2>\", \"<user ID n>\" ] Response: { \"data\": { \"status\": \"OK\" }, \"status_code\": 200 }","title":"POST /heartbeat"},{"location":"md/rest/#post-full-history","text":"To get all messages sent by a user, call this endpoint with the following data: { \"user_id\": 1971 \"from_time\": \"2016-12-26T08:39:54Z\", # optional (other needed if this one is specified) \"to_time\": \"2016-12-28T08:39:54Z\" # optional (other needed if this one is specified) } Response looks like this: { \"status_code\": 200, \"data\": [{ \"message_id\": \"07bacdd8-42e6-4ace-acee-8d200dd14bfc\", \"from_user_id\": \"1971\", \"from_user_name\": \"Um9k=\", \"target_id\": \"7935a673-da64-4419-818b-e6e0d1864b61\", \"target_name\": \"TG9iYnk=\", \"body\": \"eyJtYXNrIjoiMDAiLCJ6IjE2IiwidGV4dCI6ImkgYW0gaW52aXNpYmxlIn0=\", \"domain\": \"room\", \"channel_id\": \"84ec4b4f-7482-48ba-83a1-9c9b1c470903\", \"channel_name\": \"UGVu\", \"timestamp\": \"2017-05-23T07:32:07Z\", \"deleted\": true }, {...}] }","title":"POST /full-history"},{"location":"md/rest/#post-broadcast","text":"Broadcasts a message to everyone on the server. Request needs the body and verb keys: { \"body\": \"aGkgdGhlcmU=\", \"verb\": \"broadcast\" } Body needs to be in base64. The verb may be anything, it's up to clients to handle it.","title":"POST /broadcast"},{"location":"md/rest/#post-blacklist","text":"Add a new word to the blacklist. Encode the word in base64 first, then post a request on the following format: { \"word\": \"YmFkd29yZA==\" } Response if OK: { \"status_code\": 200 }","title":"POST /blacklist"},{"location":"md/rest/#delete-blacklist","text":"Remove a matching word from the blacklist. Encode the word in base64 first, then post a request on the following format: { \"word\": \"YmFkd29yZA==\" } The sent word will be compared lowercase to find matching lowercased word in the blacklist and remove all words with and exact match (when both lowercase). Response if OK: { \"status_code\": 200 }","title":"DELETE /blacklist"},{"location":"md/rest/#post-set-admin","text":"Set a user as a global moderator. Request contains user ID and the user's name (in case the user doesn't exist): { \"id\": \"1234\", \"name\": \"myuser\" } Response if OK: { \"status_code\": 200 } Or if any errors: { \"data\": \"no name parameter in request\", \"status_code\": 500 }","title":"POST /set-admin"},{"location":"md/rest/#post-remove-admin","text":"Remove global moderator status for a user. Request contains the user's ID only: { \"id\": \"1234\" } Response if OK: { \"status_code\": 200 } Or if any errors: { \"data\": \"no id parameter in request\", \"status_code\": 500 }","title":"POST /remove-admin"},{"location":"md/rest/#post-ban","text":"Request contains info on who to ban where. For banning globally: { \"1234\": { \"duration\": \"24h\", \"reason\": \"<optional base64 encoded free-text>\", \"admin_id\": \"<id of user banning (must already exist), or leave empty for default>\", \"type\": \"global\", \"name\": \"<username in base64, optional>\" } } Can also ban multiple users at the same time: { \"<user id>\": { \"duration\": \"24h\", \"type\": \"global\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is banning>\", \"name\": \"<username in base64, optional>\" }, \"<user id>\": { \"duration\": \"10m\", \"target\": \"<channel uuid>\", \"type\": \"channel\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is banning>\" }, \"<user id>\": { \"duration\": \"7d\", \"target\": \"<room uuid>\", \"type\": \"room\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is banning>\" } } The name field must be base64 encoded. The field is also optional and is only used if a ban request is received for a user that doesn't exist on the server, e.g. if the user never logged in before it will not exist. If the name is not specified, and the user has to be created before banning, the user ID will be set as the name (later when the user login the real username will overwrite this). The reason field must be base64 encoded. If the admin_id field is specified it will be used, if not the default ID 0 will be used (the default admin user). Duration is an integer followed by a char for the unit, which can be one of d , h , m , s (days, hours, minutes, seconds). Negative or 0 durations are not allowed. When type is set to global , no target is specified (meaning user is banned from the whole chat server). Response will be something like the following (if failure): { \"status\": \"FAIL\", \"message\": \"missing target id for user id <user id> and request <the request json>\" } The banning is done async so if any of the provided user bans has invalid parameters the response will only tell you the first non-valid parameter and for which user ID. For success the response looks like this: { \"status\": \"OK\" }","title":"POST /ban"},{"location":"md/rest/#post-kick","text":"Request contains: { \"<user id>\": { \"target\": \"<room uuid>\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is kicking>\" }, \"<user id>\": { \"target\": \"<room uuid>\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is kicking>\" }, \"<user id>\": { \"target\": \"<room uuid>\", \"reason\": \"<option reason field, base64 encoded>\", \"admin_id\": \"<optional id of admin user who is kicking>\" } } The \"reason\" field must be base64 encoded. If the \"admin_id\" field is specified it will be used, if not the default ID \"0\" will be used. Response will be something like the following: { \"<user id>\": { \"status\": \"OK\" }, \"<user id>\": { \"status\": \"FAIL\", \"message\": \"no such user\" }, \"<user id>\": { \"status\": \"OK\" } }","title":"POST /kick"},{"location":"md/rest/#get-roles","text":"Request contains a list of user IDs, e.g.: { \"users\": [ \"124352\", \"5678\" ] } Response would be something similar to the following: { \"data\": { \"124352\": { \"room\": { \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\": [ \"moderator\" ], \"bb0ea500-cd94-11e6-b178-8323deb605bf\": [ \"owner\" ] }, \"channel\": { \"dedf878e-b25d-4713-8058-20c6f0547c59\": [ \"admin\", \"owner\" ] }, \"global\": [ \"superuser\", \"globalmod\" ] }, \"5678\": { \"room\": {}, \"channel\": {}, \"global\": [] } }, \"status_code\": 200 } Possible roles are: global superuser (superuser) global moderator (globalmod) channel owner (owner) channel admin (admin) room owner (owner) room moderator (moderator) The only difference between global superusers and global moderators is that global superusers can also remove static rooms.","title":"GET /roles"},{"location":"md/rest/#get-count-joins","text":"Count the cumulative number of joins for a room. Used for counting the number of \"views\" a live stream has had. The count is cached for 8 hours, then fetched from db if requested again. Using curl: curl localhost:7300/count-joins -X GET -H 'Content-Type: application/json' -d @- << EOF { \"room_ids\": [\"2e7d537e-bed5-47c5-a7f6-357075759e5d\"] } EOF Instead of room_ids , we can use room_names (base64 encoded) instead (only works for rooms in the default channel, e.g. created using POST /create ): curl localhost:7300/count-joins -X GET -H 'Content-Type: application/json' -d @- << EOF { \"room_names\": [\"c29tZSByb29tIG5hbWUK\"] } EOF If room IDs were used in the request, the keys in the response will also be room IDs, but if room names were used, the base64 encoded room name will be the key: { \"status_code\": 200, \"data\": { \"2e7d537e-bed5-47c5-a7f6-357075759e5d\": 5, \"0e88aae3-cb2f-457c-b1be-8e882479bd34\": 3290, \"0c289aaf-3c7b-4290-89bb-e1fa27cd2300\": 89 } }","title":"GET /count-joins"},{"location":"md/rest/#get-users-in-rooms","text":"Request contains a list of room IDs, and an optional only_count field (default is false ), e.g.: { \"room_ids\": [ \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\", \"2e7d537e-bed5-47c5-a7f6-357075759e5d\" ], \"only_count\": false } Instead of room IDs, we can specify room names (base64 encoded): { \"room_names\": [ \"c29tZSByb29tIG5hbWUK\" ] } Response would be all visible users in the specified rooms, with their user infos attached ( roles is a comma-separated list of roles, e.g. owner,globalmod ). If room IDs were used in the request, the keys in the response will also be room IDs, but if room names were used, the base64 encoded room name will be the key: { \"data\": { \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\": [{ \"id\": \"898121\", \"info\": { \"membership\": \"MA==\", \"has_webcam\": \"eQ==\", \"age\": \"OTk=\", \"is_streaming\": \"RmFsc2U=\", \"city\": \"U2FzZGY=\", \"fake_checked\": \"eQ==\", \"country\": \"Y24=\", \"gender\": \"bQ==\", \"image\": \"eQ==\" }, \"roles\": \"owner\", \"name\": \"Um9iYnk=\" }], \"2e7d537e-bed5-47c5-a7f6-357075759e5d\": [] }, \"status_code\": 200 } Response if only_count is true : { \"data\": { \"2ddd90ac-1d44-4af5-9c7d-b9191bc35675\": 5, \"2e7d537e-bed5-47c5-a7f6-357075759e5d\": 2 }, \"status_code\": 200 }","title":"GET /users-in-rooms"},{"location":"md/rest/#post-create","text":"Creates and joins the room (if specified users are online). Rooms created using this API will always be in the default channel. Example request: { \"user_ids\": [ \"1234\", \"5678\" ], \"room_name\": \"<a room name, in base64>\", \"owner_id\": \"<a user id>\", \"owner_name\": \"<a user name, in base64>\" } Example response: { \"status_code\": 200, \"data\": { \"room_id\": \"01eafcf0-4ab2-48bb-8ff5-833b056d2727\", \"room_name\": \"tr19\", \"channel_id\": \"8d43181a-13e0-4ccc-a64b-ae8e93d36bcd\" } }","title":"POST /create"},{"location":"md/rest/#post-join","text":"Joins the room (if specified users are online). Only works for rooms in the default channel (e.g. rooms created using the POST /create API). If room_id is specified, it will be used, otherwise, the room_name will be used to lookup the correct room in the default channel. Example request: { \"user_ids\": [ \"1234\", \"5678\" ], \"room_id\": \"<optional: a room id>\", \"room_name\": \"<a room name, in base64>\" } Example response: { \"status_code\": 200 }","title":"POST /join"},{"location":"md/rest/#post-leave","text":"Leaves the room (if specified users are online). Only works for rooms in the default channel (e.g. rooms created using the POST /create API). If room_id is specified, it will be used, otherwise, the room_name will be used to lookup the correct room in the default channel. Example request: { \"user_ids\": [ \"1234\", \"5678\" ], \"room_id\": \"<optional: a room id>\", \"room_name\": \"<a room name, in base64>\" } Example response: { \"status_code\": 200 }","title":"POST /leave"},{"location":"md/rest/#get-rooms-for-users","text":"Request contains a list of user IDs, e.g.: { \"users\": [ \"1234\", \"5678\" ] } Response would be all rooms each user is currently in (room names and channel names are base64 encoded): { \"1234\": [{ \"room_id\": \"efeca2fe-ba93-11e6-bc9a-4f6f56293063\", \"room_name\": \"b2gsIHNvIHlvdSBhY3R1YWxseSBjaGVja2VkIHdoYXQgaXMgd2FzPw==\", \"channel_id\": \"fb843140-ba93-11e6-b178-97f0297a6d4d\", \"channel_name\": \"dG9tIGlzIGEgZnJlbmNoIG1hZG1hbg==\" }], \"5678\": [{ \"room_id\": \"ca1dc3b4-ba93-11e6-b835-7f1d961023a1\", \"room_name\": \"cmVhZCB1cCBvbiBoeXBlcmxvZ2xvZysr\", \"channel_id\": \"f621fcaa-ba93-11e6-8590-bfe35ff80c03\", \"channel_name\": \"YSByZWRidWxsIGEgZGF5IGtlZXBzIHRoZSBzYW5kbWFuIGF3YXk=\" }] }","title":"GET /rooms-for-users"},{"location":"md/rest/#post-delete-messages","text":"Used to delete ALL messages for a specific user ID. Request body looks like this: { \"id\": \"<user ID>\" } Example response: { \"status_code\": 200, \"data\": { \"success\": 4, \"failed\": 0, \"total\": 4 } } Or if other kinds of failures: { \"status_code\": 500, \"data\": \"<error message, e.g. 'no id parameter in request'>\" }","title":"POST /delete-messages"},{"location":"md/rest/#get-banned","text":"No data required in request. Response is all banned users, separated by channel, room and globally. Example response: { \"channels\": {}, \"global\": { \"185626\": { \"name\": \"bHVlbA==\", \"duration\": \"1h\", \"timestamp\": \"2016-12-05T03:50:24Z\" } }, \"rooms\": { \"1aa3f5f5-ba46-4aca-999a-978c7f2237c7\": { \"name\": \"Y29vbCBndXlz\", \"users\": { \"101108\": { \"name\": \"bHVlbA==\", \"duration\": \"30m\", \"timestamp\": \"2016-12-05T03:20:24Z\" } } } } } The \"timestamp\" in the response is the UTC timestamp for when the ban will expire. Names or channels, rooms and users are all base64 encoded. The dictionary keys for \"rooms\" are the UUIDs of the rooms, same for channels, while for users it's their user IDs as keys. The bans for \"global\" have no separation by room/channel IDs, and no \"name\" or \"users\" keys.","title":"GET /banned"},{"location":"md/rest/#post-status","text":"Set the online status or visibility status of a user. Request contains: { \"id\": \"<user ID>\", \"status\": \"<one of online/offline/invisible/visible>\", \"stage\": \"<one of login/status>\" } Example response: { \"status_code\": 200 }","title":"POST /status"},{"location":"md/rest/#post-send","text":"If target_id is not specified in the request body, but target_name is, Dino will try to send the message to the room with that name, but it only works for rooms that are in the default channel (rooms created using POST /create are always in the default channel). The target_name field (if specified), must be base64 encoded. Request contains: { \"user_id\": \"<user ID>\", \"user_name\": \"<username, in base64>\", \"object_type\": \"<room/private>\", \"target_id\": \"<user ID to send to or UUID of room to send to>\", \"target_name\": \"<the name of the user/room to send to, in base64>\", \"content\": \"<the body to send, in base64>\" } Example response: { \"status_code\": 200 } User/room will get something similar to this in a message event: { \"id\": \"1d805e18-a773-11e8-a65f-8b33c55c9e1b\", \"published\": \"2017-01-26T04:58:31Z\", \"actor\": { \"id\": \"<user ID>\", \"displayName\": \"<username, in base64>\" }, \"verb\": \"send\", \"target\": { \"objectType\": \"<room/private>\", \"id\": \"<user ID to send to or UUID of room to send to>\", \"displayName\": \"<the name of the user/room to send to, in base64>\" }, \"object\": { \"content\": \"<the body to send, in base64>\" } }","title":"POST /send"},{"location":"md/storage/","text":"Storage All events can be stored in four different storage types: Cassandra, Riak, Redis, Any RDBMS supported by SqlAlchemy. Cassandra \"The Apache Cassandra database is the right choice when you need scalability and high availability without compromising performance. Linear scalability and proven fault-tolerance on commodity hardware or cloud infrastructure make it the perfect platform for mission-critical data.Cassandra's support for replicating across multiple datacenters is best-in-class, providing lower latency for your users and the peace of mind of knowing that you can survive regional outages.\" Riak KV Riak KV with LevelDB backend. \"Riak KV is a distributed NoSQL key-value database with advanced local and multi-cluster replication that guarantees reads and writes even in the event of hardware failures or network partitions.\" Redis \"Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.\" SqlAlchemy The following dialects are supports out-of-the-box by SqlAlchemy: Firebird, Microsoft SQL Server, MySQL, Oracle, PostgreSQL, SQLite, Sybase. External production ready dialects: IBM DB2, Amazon Redshift, EXASolution, SAP Sybase SQL Anywhere, MonetDB, Snowflake, CrateDB.","title":"Storage"},{"location":"md/storage/#storage","text":"All events can be stored in four different storage types: Cassandra, Riak, Redis, Any RDBMS supported by SqlAlchemy.","title":"Storage"},{"location":"md/storage/#cassandra","text":"\"The Apache Cassandra database is the right choice when you need scalability and high availability without compromising performance. Linear scalability and proven fault-tolerance on commodity hardware or cloud infrastructure make it the perfect platform for mission-critical data.Cassandra's support for replicating across multiple datacenters is best-in-class, providing lower latency for your users and the peace of mind of knowing that you can survive regional outages.\"","title":"Cassandra"},{"location":"md/storage/#riak-kv","text":"Riak KV with LevelDB backend. \"Riak KV is a distributed NoSQL key-value database with advanced local and multi-cluster replication that guarantees reads and writes even in the event of hardware failures or network partitions.\"","title":"Riak KV"},{"location":"md/storage/#redis","text":"\"Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.\"","title":"Redis"},{"location":"md/storage/#sqlalchemy","text":"The following dialects are supports out-of-the-box by SqlAlchemy: Firebird, Microsoft SQL Server, MySQL, Oracle, PostgreSQL, SQLite, Sybase. External production ready dialects: IBM DB2, Amazon Redshift, EXASolution, SAP Sybase SQL Anywhere, MonetDB, Snowflake, CrateDB.","title":"SqlAlchemy"},{"location":"md/usage/","text":"Create rooms and send messages using the room name instead of ID Useful REST APIs that support room_name instead of room_id : WS join , WS leave , POST /create , POST /join , POST /send , POST /leave , POST /ban , POST /kick , GET /users-in-rooms , GET /count-joins . The client connects and logs in as normal (example user ID 1234 ): socket = io.connect( 'http://' + document.domain + ':' + location.port + '/chat', {transports:['websocket']} ); socket.on('connect', function() { socket.emit('login', { verb: 'login', actor: { id: '1234', attachments: [ { objectType: 'token', content: '<auth token>' } ] } }); }); Creating rooms The REST API /create can then be called to create a new room for this user (the user will automatically join the room as well). All rooms created using the POST /create API will be temporary rooms in the default channel, meaning that no channel ID has to be specified when interacting with these rooms: curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/create -d @- << EOF { \"user_ids\": [ \"1234\" ], \"room_name\": \"dGVzdCByb29tIG5hbWU=\", \"owner_id\": \"1234\", \"owner_name\": \"dGVzdCB1c2Vy\" } EOF The response from the REST API (the channel_id is the ID of the default channel for the rooms, and is not necessary to know for clients): { \"status_code\": 200, \"data\": { \"channel_id\": \"8d43181a-13e0-4ccc-a64b-ae8e93d36bcd\", \"room_name\": \"dGVzdCByb29tIG5hbWU=\", \"room_id\": \"24a65e40-91e3-4ef7-8e15-e01196550482\" } } The client will now receive two events over the websocket connection, first one gn_room_created : { \"actor\": { \"id\": \"1234\", \"displayName\": \"dGVzdCB1c2Vy\", \"attachments\": [{ \"objectType\": \"age\", \"content\": \"MTg=\" }, {\"many\":\"more\"}] }, \"object\": { \"url\": \"/ws\" }, \"target\": { \"id\": \"8fdef765-ca8d-4f0a-9340-aaaea478d1c5\", \"displayName\": \"dGVzdCByb29tIG5hbWU=\", \"objectType\": \"temporary\" }, \"verb\": \"create\", \"id\": \"b2a8ccbf-f768-4cc3-8f6b-39569533f743\", \"published\": \"2021-03-17T07:17:24Z\", \"provider\": { \"id\": \"some-provider\" } } ...then one gn_user_joined for the same user (see next section). Joining a room using the WS api Simply add objectType: \"room\" to the target object: { \"verb\": \"join\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } The response is the same as described in the join API. Joining a room using the REST api The REST API POST /join can now be used for rooms created in the default channel, by specifying the name of the room instead of the id of the room (multiple user IDs can be specified to have them all join): curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/join -d @- << EOF { \"user_ids\": [ \"4321\" ], \"room_name\": \"dGVzdCByb29tIG5hbWU=\" } EOF Response from the REST API: { \"status_code\": 200 } The user who just joined, and everyone else already in the room, now received a gn_user_joined event: { \"actor\": { \"id\": \"4321\", \"displayName\": \"dGVzdCB1c2Vy\", \"image\": { \"url\": \"https://some-url/image.jpg\" }, \"attachments\": [{ \"objectType\": \"age\", \"content\": \"MTg=\" }, {\"many\":\"more\"}], \"content\": \"owner\" }, \"target\": { \"id\": \"8fdef765-ca8d-4f0a-9340-aaaea478d1c5\", \"displayName\": \"dGVzdCByb29tIG5hbWU=\" }, \"verb\": \"join\", \"id\": \"a791c846-6070-4cac-a591-a87c298bf7a2\", \"published\": \"2021-03-17T07:17:24Z\", \"provider\": { \"id\": \"some-provider\" } } Sending message to a room Using the REST API POST /send , we can send messages to the room using the name as well (if no user ID is specified, the ID 0 and name admin will be used): curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/send -d @- << EOF { \"user_id\": \"1234\", \"user_name\": \"dGVzdCB1c2Vy\", \"object_type\": \"room\", \"target_name\": \"dGVzdCByb29tIG5hbWU=\", \"content\": \"dGVzdCBjb250ZW50\" } EOF Response from the REST API: { \"status_code\": 200 } All users in the room now receive a message event: { \"object\": { \"content\": \"dGVzdCBjb250ZW50\" }, \"provider\": { \"id\": \"some-provider\" }, \"target\": { \"objectType\": \"room\", \"id\": \"8fdef765-ca8d-4f0a-9340-aaaea478d1c5\", \"url\": \"/ws\", \"displayName\": \"dGVzdCByb29tIG5hbWU=\" }, \"actor\": { \"id\": \"1234\", \"displayName\": \"dGVzdCB1c2Vy\" }, \"verb\": \"send\", \"id\": \"f29a1633-5de2-4185-9014-26c15af41896\", \"published\": \"2021-03-17T07:17:40Z\" } Leaving a room using the WS api Simply add objectType: \"room\" to the target object: { \"verb\": \"leave\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } The response is the same as described in the leave API. Leaving a room using the REST api When leaving the room, call the REST API POST /leave : curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/leave -d @- << EOF { \"user_ids\": [\"1234\"], \"room_name\": \"dGVzdCByb29tIG5hbWU=\" } EOF Response from REST API: { \"status_code\": 200 } Banning a user To ban a user, call the /ban API. The request: curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/ban -d @- << EOF { \"921984\": { \"room_name\": \"YSB0ZXN0IHJvb20gMg==\", \"type\": \"room\", \"duration\": \"1s\" } } EOF Response from the REST API: { \"status_code\": 200, \"data\": { \"status\": \"OK\" } } The banned user will receive three events; gn_banned (only the banned user gets this event), gn_user_banned (all users in the room get this event, including the banned user) and finally a gn_user_kicked event (all users in the room gets this event as well, including the banned user). The gn_banned event (YOU were banned): { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"verb\": \"ban\", \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\", \"summary\": \"1s\", \"updated\": \"2021-03-19T07:53:25Z\" }, \"id\": \"b564c6df-9f6b-4a9d-ab60-dca04f4d9416\", \"published\": \"2021-03-19T07:53:24Z\", \"target\": { \"objectType\": \"room\", \"id\": \"77395763-6d11-4b06-b890-83bfb9c31b89\", \"displayName\": \"dGVzdCByb29tIDM=\" }, \"provider\": { \"id\": \"some-provider\" } } The gn_user_banned event (a user in a room was banned, not necessarily you): { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\" }, \"target\": { \"id\": \"77395763-6d11-4b06-b890-83bfb9c31b89\", \"displayName\": \"dGVzdCByb29tIDM=\" }, \"verb\": \"ban\", \"id\": \"3fbc29e0-4807-4170-a23a-b41c94b1bd69\", \"published\": \"2021-03-19T07:53:24Z\", \"provider\": { \"id\": \"some-provider\" } } Finally, the gn_user_kicked event, telling people the user has been removed from the room (even the banned user gets this event): { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\" }, \"target\": { \"id\": \"77395763-6d11-4b06-b890-83bfb9c31b89\" }, \"verb\": \"ban\", \"id\": \"3fbc29e0-4807-4170-a23a-b41c94b1bd69\", \"published\": \"2021-03-19T07:53:24Z\", \"provider\": { \"id\": \"some-provider\" } } Kicking a user Note: instead of using the /kick API, the /ban api can be used with duration set to 1s . To kick a user, call the /ban API. The request: curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/kick -d @- << EOF { \"921984\": { \"room_name\": \"YSB0ZXN0IHJvb20gMg==\" } } EOF Response from the REST API: { \"status_code\": 200, \"data\": { \"921984\": \"OK\" } } Everyone in the room, including the kicked user, will receive the gn_user_kicked event: { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\" }, \"target\": { \"id\": \"683fab21-fcb3-473e-bdab-49ab44600200\" }, \"verb\": \"kick\", \"id\": \"d182efbf-070e-482c-b6b1-929c90b5bb2c\", \"published\": \"2021-03-19T07:47:16Z\", \"provider\": { \"id\": \"some-provider\" } }","title":"Usage"},{"location":"md/usage/#create-rooms-and-send-messages-using-the-room-name-instead-of-id","text":"Useful REST APIs that support room_name instead of room_id : WS join , WS leave , POST /create , POST /join , POST /send , POST /leave , POST /ban , POST /kick , GET /users-in-rooms , GET /count-joins . The client connects and logs in as normal (example user ID 1234 ): socket = io.connect( 'http://' + document.domain + ':' + location.port + '/chat', {transports:['websocket']} ); socket.on('connect', function() { socket.emit('login', { verb: 'login', actor: { id: '1234', attachments: [ { objectType: 'token', content: '<auth token>' } ] } }); });","title":"Create rooms and send messages using the room name instead of ID"},{"location":"md/usage/#creating-rooms","text":"The REST API /create can then be called to create a new room for this user (the user will automatically join the room as well). All rooms created using the POST /create API will be temporary rooms in the default channel, meaning that no channel ID has to be specified when interacting with these rooms: curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/create -d @- << EOF { \"user_ids\": [ \"1234\" ], \"room_name\": \"dGVzdCByb29tIG5hbWU=\", \"owner_id\": \"1234\", \"owner_name\": \"dGVzdCB1c2Vy\" } EOF The response from the REST API (the channel_id is the ID of the default channel for the rooms, and is not necessary to know for clients): { \"status_code\": 200, \"data\": { \"channel_id\": \"8d43181a-13e0-4ccc-a64b-ae8e93d36bcd\", \"room_name\": \"dGVzdCByb29tIG5hbWU=\", \"room_id\": \"24a65e40-91e3-4ef7-8e15-e01196550482\" } } The client will now receive two events over the websocket connection, first one gn_room_created : { \"actor\": { \"id\": \"1234\", \"displayName\": \"dGVzdCB1c2Vy\", \"attachments\": [{ \"objectType\": \"age\", \"content\": \"MTg=\" }, {\"many\":\"more\"}] }, \"object\": { \"url\": \"/ws\" }, \"target\": { \"id\": \"8fdef765-ca8d-4f0a-9340-aaaea478d1c5\", \"displayName\": \"dGVzdCByb29tIG5hbWU=\", \"objectType\": \"temporary\" }, \"verb\": \"create\", \"id\": \"b2a8ccbf-f768-4cc3-8f6b-39569533f743\", \"published\": \"2021-03-17T07:17:24Z\", \"provider\": { \"id\": \"some-provider\" } } ...then one gn_user_joined for the same user (see next section).","title":"Creating rooms"},{"location":"md/usage/#joining-a-room-using-the-ws-api","text":"Simply add objectType: \"room\" to the target object: { \"verb\": \"join\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } The response is the same as described in the join API.","title":"Joining a room using the WS api"},{"location":"md/usage/#joining-a-room-using-the-rest-api","text":"The REST API POST /join can now be used for rooms created in the default channel, by specifying the name of the room instead of the id of the room (multiple user IDs can be specified to have them all join): curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/join -d @- << EOF { \"user_ids\": [ \"4321\" ], \"room_name\": \"dGVzdCByb29tIG5hbWU=\" } EOF Response from the REST API: { \"status_code\": 200 } The user who just joined, and everyone else already in the room, now received a gn_user_joined event: { \"actor\": { \"id\": \"4321\", \"displayName\": \"dGVzdCB1c2Vy\", \"image\": { \"url\": \"https://some-url/image.jpg\" }, \"attachments\": [{ \"objectType\": \"age\", \"content\": \"MTg=\" }, {\"many\":\"more\"}], \"content\": \"owner\" }, \"target\": { \"id\": \"8fdef765-ca8d-4f0a-9340-aaaea478d1c5\", \"displayName\": \"dGVzdCByb29tIG5hbWU=\" }, \"verb\": \"join\", \"id\": \"a791c846-6070-4cac-a591-a87c298bf7a2\", \"published\": \"2021-03-17T07:17:24Z\", \"provider\": { \"id\": \"some-provider\" } }","title":"Joining a room using the REST api"},{"location":"md/usage/#sending-message-to-a-room","text":"Using the REST API POST /send , we can send messages to the room using the name as well (if no user ID is specified, the ID 0 and name admin will be used): curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/send -d @- << EOF { \"user_id\": \"1234\", \"user_name\": \"dGVzdCB1c2Vy\", \"object_type\": \"room\", \"target_name\": \"dGVzdCByb29tIG5hbWU=\", \"content\": \"dGVzdCBjb250ZW50\" } EOF Response from the REST API: { \"status_code\": 200 } All users in the room now receive a message event: { \"object\": { \"content\": \"dGVzdCBjb250ZW50\" }, \"provider\": { \"id\": \"some-provider\" }, \"target\": { \"objectType\": \"room\", \"id\": \"8fdef765-ca8d-4f0a-9340-aaaea478d1c5\", \"url\": \"/ws\", \"displayName\": \"dGVzdCByb29tIG5hbWU=\" }, \"actor\": { \"id\": \"1234\", \"displayName\": \"dGVzdCB1c2Vy\" }, \"verb\": \"send\", \"id\": \"f29a1633-5de2-4185-9014-26c15af41896\", \"published\": \"2021-03-17T07:17:40Z\" }","title":"Sending message to a room"},{"location":"md/usage/#leaving-a-room-using-the-ws-api","text":"Simply add objectType: \"room\" to the target object: { \"verb\": \"leave\", \"target\": { \"id\": \"<room name>\", \"objectType\": \"name\" } } The response is the same as described in the leave API.","title":"Leaving a room using the WS api"},{"location":"md/usage/#leaving-a-room-using-the-rest-api","text":"When leaving the room, call the REST API POST /leave : curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/leave -d @- << EOF { \"user_ids\": [\"1234\"], \"room_name\": \"dGVzdCByb29tIG5hbWU=\" } EOF Response from REST API: { \"status_code\": 200 }","title":"Leaving a room using the REST api"},{"location":"md/usage/#banning-a-user","text":"To ban a user, call the /ban API. The request: curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/ban -d @- << EOF { \"921984\": { \"room_name\": \"YSB0ZXN0IHJvb20gMg==\", \"type\": \"room\", \"duration\": \"1s\" } } EOF Response from the REST API: { \"status_code\": 200, \"data\": { \"status\": \"OK\" } } The banned user will receive three events; gn_banned (only the banned user gets this event), gn_user_banned (all users in the room get this event, including the banned user) and finally a gn_user_kicked event (all users in the room gets this event as well, including the banned user). The gn_banned event (YOU were banned): { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"verb\": \"ban\", \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\", \"summary\": \"1s\", \"updated\": \"2021-03-19T07:53:25Z\" }, \"id\": \"b564c6df-9f6b-4a9d-ab60-dca04f4d9416\", \"published\": \"2021-03-19T07:53:24Z\", \"target\": { \"objectType\": \"room\", \"id\": \"77395763-6d11-4b06-b890-83bfb9c31b89\", \"displayName\": \"dGVzdCByb29tIDM=\" }, \"provider\": { \"id\": \"some-provider\" } } The gn_user_banned event (a user in a room was banned, not necessarily you): { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\" }, \"target\": { \"id\": \"77395763-6d11-4b06-b890-83bfb9c31b89\", \"displayName\": \"dGVzdCByb29tIDM=\" }, \"verb\": \"ban\", \"id\": \"3fbc29e0-4807-4170-a23a-b41c94b1bd69\", \"published\": \"2021-03-19T07:53:24Z\", \"provider\": { \"id\": \"some-provider\" } } Finally, the gn_user_kicked event, telling people the user has been removed from the room (even the banned user gets this event): { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\" }, \"target\": { \"id\": \"77395763-6d11-4b06-b890-83bfb9c31b89\" }, \"verb\": \"ban\", \"id\": \"3fbc29e0-4807-4170-a23a-b41c94b1bd69\", \"published\": \"2021-03-19T07:53:24Z\", \"provider\": { \"id\": \"some-provider\" } }","title":"Banning a user"},{"location":"md/usage/#kicking-a-user","text":"Note: instead of using the /kick API, the /ban api can be used with duration set to 1s . To kick a user, call the /ban API. The request: curl -X POST -H 'Content-Type: application/json' http://the-host-name:8080/kick -d @- << EOF { \"921984\": { \"room_name\": \"YSB0ZXN0IHJvb20gMg==\" } } EOF Response from the REST API: { \"status_code\": 200, \"data\": { \"921984\": \"OK\" } } Everyone in the room, including the kicked user, will receive the gn_user_kicked event: { \"actor\": { \"id\": \"0\", \"displayName\": \"YWRtaW4=\" }, \"object\": { \"id\": \"921984\", \"displayName\": \"YWRzZmZhZHNkZmFzYWZkcw==\" }, \"target\": { \"id\": \"683fab21-fcb3-473e-bdab-49ab44600200\" }, \"verb\": \"kick\", \"id\": \"d182efbf-070e-482c-b6b1-929c90b5bb2c\", \"published\": \"2021-03-19T07:47:16Z\", \"provider\": { \"id\": \"some-provider\" } }","title":"Kicking a user"},{"location":"md/web/","text":"GET /api/spam Get the latest messages classified as spam. user@box:~$ curl -X GET localhost:4556/api/spam Response would be something similar to the following: { \"data\": [{ \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 8, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": true, \"message_id\": \"42957c6c-6290-4744-8e79-8c6e3fe7319b\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535312965, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }, { \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 7, \"message\": \"gfdhgdf\", \"message_deleted\": true, \"message_id\": \"75550bd5-faa8-4393-b8da-65141f46898c\", \"object_type\": \"room\", \"probability\": \"0.81171554,0.99,1\", \"time_stamp\": 1535312962, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }], \"message\": \"\", \"status_code\": 200 } POST /api/spam/search Search for spam messages given a time range and either a room uuid or user ID of a sender. user@box:~$ curl -X POST localhost:4556/api/spam/search -H 'Content-Type: application/json' -d '{\"room\":\"9fa5b40a-f0a6-44ea-93c1-acf2947e5f09\",\"from\":\"2018-08-26T04:00:00Z\",\"to\":\"2018-08-27T04:00:00Z\"}' Response would be something similar to the following: { \"data\": [{ \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 8, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": true, \"message_id\": \"42957c6c-6290-4744-8e79-8c6e3fe7319b\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535312965, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }, { \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 7, \"message\": \"gfdhgdf\", \"message_deleted\": true, \"message_id\": \"75550bd5-faa8-4393-b8da-65141f46898c\", \"object_type\": \"room\", \"probability\": \"0.81171554,0.99,1\", \"time_stamp\": 1535312962, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }], \"message\": \"\", \"status_code\": 200 } GET /api/spam/<spam_id> Get one spam message. Request: user@box:~$ curl -X GET localhost:4556/api/spam/3 Response: { \"data\": { \"correct\": true, \"from_id\": \"115584\", \"from_name\": \"\", \"id\": 3, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": false, \"message_id\": \"21aa49f3-3dc5-4bef-a08d-84f7a516bf49\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535309860, \"to_id\": \"115584\", \"to_name\": \"jkvkjvh\" }, \"message\": \"\", \"status_code\": 200 } POST /api/spam/<spam_id>/incorrect Set a spam message as incorrectly classified. The correct flag on this spam messages will be false after this. Request: user@box:~$ curl -X POST localhost:4556/api/spam/3/incorrect Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } POST /api/spam/<spam_id>/correct Set a spam message as correctly classified. The correct flag on this spam messages will be true after this. Request: user@box:~$ curl -X POST localhost:4556/api/spam/3/correct Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } POST /api/spam/enable Enable the spam classifier. When enabled, the classifier will prevent messages being broadcasted that has been classified as spam. If disabled, it will still classify them, but it won't prevent them from being broadcasted. Request: user@box:~$ curl -X POST localhost:4556/api/spam/enable Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } POST /api/spam/disable Disable the spam classifier. When enabled, the classifier will prevent messages being broadcasted that has been classified as spam. If disabled, it will still classify them, but it won't prevent them from being broadcasted. Request: user@box:~$ curl -X POST localhost:4556/api/spam/disable Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } GET /api/spam/isenabled Check if the spam classifier is enabled or not. When enabled, the classifier will prevent messages being broadcasted that has been classified as spam. If disabled, it will still classify them, but it won't prevent them from being broadcasted. Request: user@box:~$ curl -X GET localhost:4556/api/spam/isenabled Response: { \"data\": {}, \"message\": \"enabled\", \"status_code\": 200 } Example: user@box:~$ curl -X POST localhost:4556/api/spam/disable { \"data\": {}, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X GET localhost:4556/api/spam/isenabled { \"data\": {}, \"message\": \"disabled\", \"status_code\": 200 } user@box:~$ curl -X POST localhost:4556/api/spam/enable { \"data\": {}, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X GET localhost:4556/api/spam/isenabled { \"data\": {}, \"message\": \"enabled\", \"status_code\": 200 } GET /api/spam/settings Get the current settings for the spam classifier. Response: { \"data\": { \"enabled\": true, \"max_length\": 250, \"min_length\": 10, \"threshold\": 80, \"ignore_emoji\": true, \"should_delete\": false, \"should_save\": false }, \"message\": \"\", \"status_code\": 200 } POST /api/spam/settings Set the current settings for the spam classifier. One or more settings can be specified in the dictionary. Request: user@box:~$ curl -X POST localhost:4556/api/spam/settings -H 'Content-Type: application/json' -d '{\"enabled\":true,\"max_length\":250,\"min_length\":10,\"should_delete\":false,\"should_save\":false,\"ignore_emoji\":true,\"threshold\":80}' Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } PUT /api/spam/set/minlen/<min_length> set min length of message that should be checked for spam. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } PUT /api/spam/set/maxlen/<min_length> set max length of message that should be checked for spam. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } POST /api/spam/disable/save Disable saving of spam messages to separate 'spams' table. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } POST /api/spam/disable/delete Disable deletion of spam messages from storage backend. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } POST /api/spam/enable/save Enable saving of spam messages to separate 'spams' table. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } POST /api/spam/enable/delete Enable deletion of spam messages from storage backend. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 } Deleting a message classified as spam The message_id field describes the ID of the message stored in the message store. It can be deleted by using the history web API: user@box:~$ curl -X GET localhost:4556/api/spam/3 { \"data\": { \"correct\": true, \"from_id\": \"115584\", \"from_name\": \"\", \"id\": 3, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": false, \"message_id\": \"21aa49f3-3dc5-4bef-a08d-84f7a516bf49\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535309860, \"to_id\": \"115584\", \"to_name\": \"jkvkjvh\" }, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X DELETE localhost:4556/api/history/21aa49f3-3dc5-4bef-a08d-84f7a516bf49 { \"data\": {}, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X GET localhost:4556/api/spam/3 { \"data\": { \"correct\": true, \"from_id\": \"115584\", \"from_name\": \"\", \"id\": 3, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": true, \"message_id\": \"21aa49f3-3dc5-4bef-a08d-84f7a516bf49\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535309860, \"to_id\": \"115584\", \"to_name\": \"jkvkjvh\" }, \"message\": \"\", \"status_code\": 200 } Probability The field probability are percentages from three different classifiers. If at least two of them predict with a percentage of at least 66% that a message is spam, then it will be labeled as such. The first number is from XGBoost, the second from a Random Forest, and the third SVC with a polynomial kernel. The third number is always either 0 or 1 , and never a fraction.","title":"Web UI API"},{"location":"md/web/#get-apispam","text":"Get the latest messages classified as spam. user@box:~$ curl -X GET localhost:4556/api/spam Response would be something similar to the following: { \"data\": [{ \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 8, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": true, \"message_id\": \"42957c6c-6290-4744-8e79-8c6e3fe7319b\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535312965, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }, { \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 7, \"message\": \"gfdhgdf\", \"message_deleted\": true, \"message_id\": \"75550bd5-faa8-4393-b8da-65141f46898c\", \"object_type\": \"room\", \"probability\": \"0.81171554,0.99,1\", \"time_stamp\": 1535312962, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }], \"message\": \"\", \"status_code\": 200 }","title":"GET /api/spam"},{"location":"md/web/#post-apispamsearch","text":"Search for spam messages given a time range and either a room uuid or user ID of a sender. user@box:~$ curl -X POST localhost:4556/api/spam/search -H 'Content-Type: application/json' -d '{\"room\":\"9fa5b40a-f0a6-44ea-93c1-acf2947e5f09\",\"from\":\"2018-08-26T04:00:00Z\",\"to\":\"2018-08-27T04:00:00Z\"}' Response would be something similar to the following: { \"data\": [{ \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 8, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": true, \"message_id\": \"42957c6c-6290-4744-8e79-8c6e3fe7319b\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535312965, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }, { \"correct\": true, \"from_id\": \"126144\", \"from_name\": \"fuyfuyf\", \"id\": 7, \"message\": \"gfdhgdf\", \"message_deleted\": true, \"message_id\": \"75550bd5-faa8-4393-b8da-65141f46898c\", \"object_type\": \"room\", \"probability\": \"0.81171554,0.99,1\", \"time_stamp\": 1535312962, \"to_id\": \"126144\", \"to_name\": \"fdsa\" }], \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/search"},{"location":"md/web/#get-apispamspam_id","text":"Get one spam message. Request: user@box:~$ curl -X GET localhost:4556/api/spam/3 Response: { \"data\": { \"correct\": true, \"from_id\": \"115584\", \"from_name\": \"\", \"id\": 3, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": false, \"message_id\": \"21aa49f3-3dc5-4bef-a08d-84f7a516bf49\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535309860, \"to_id\": \"115584\", \"to_name\": \"jkvkjvh\" }, \"message\": \"\", \"status_code\": 200 }","title":"GET /api/spam/&lt;spam_id&gt;"},{"location":"md/web/#post-apispamspam_idincorrect","text":"Set a spam message as incorrectly classified. The correct flag on this spam messages will be false after this. Request: user@box:~$ curl -X POST localhost:4556/api/spam/3/incorrect Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/&lt;spam_id&gt;/incorrect"},{"location":"md/web/#post-apispamspam_idcorrect","text":"Set a spam message as correctly classified. The correct flag on this spam messages will be true after this. Request: user@box:~$ curl -X POST localhost:4556/api/spam/3/correct Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/&lt;spam_id&gt;/correct"},{"location":"md/web/#post-apispamenable","text":"Enable the spam classifier. When enabled, the classifier will prevent messages being broadcasted that has been classified as spam. If disabled, it will still classify them, but it won't prevent them from being broadcasted. Request: user@box:~$ curl -X POST localhost:4556/api/spam/enable Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/enable"},{"location":"md/web/#post-apispamdisable","text":"Disable the spam classifier. When enabled, the classifier will prevent messages being broadcasted that has been classified as spam. If disabled, it will still classify them, but it won't prevent them from being broadcasted. Request: user@box:~$ curl -X POST localhost:4556/api/spam/disable Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/disable"},{"location":"md/web/#get-apispamisenabled","text":"Check if the spam classifier is enabled or not. When enabled, the classifier will prevent messages being broadcasted that has been classified as spam. If disabled, it will still classify them, but it won't prevent them from being broadcasted. Request: user@box:~$ curl -X GET localhost:4556/api/spam/isenabled Response: { \"data\": {}, \"message\": \"enabled\", \"status_code\": 200 } Example: user@box:~$ curl -X POST localhost:4556/api/spam/disable { \"data\": {}, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X GET localhost:4556/api/spam/isenabled { \"data\": {}, \"message\": \"disabled\", \"status_code\": 200 } user@box:~$ curl -X POST localhost:4556/api/spam/enable { \"data\": {}, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X GET localhost:4556/api/spam/isenabled { \"data\": {}, \"message\": \"enabled\", \"status_code\": 200 }","title":"GET /api/spam/isenabled"},{"location":"md/web/#get-apispamsettings","text":"Get the current settings for the spam classifier. Response: { \"data\": { \"enabled\": true, \"max_length\": 250, \"min_length\": 10, \"threshold\": 80, \"ignore_emoji\": true, \"should_delete\": false, \"should_save\": false }, \"message\": \"\", \"status_code\": 200 }","title":"GET /api/spam/settings"},{"location":"md/web/#post-apispamsettings","text":"Set the current settings for the spam classifier. One or more settings can be specified in the dictionary. Request: user@box:~$ curl -X POST localhost:4556/api/spam/settings -H 'Content-Type: application/json' -d '{\"enabled\":true,\"max_length\":250,\"min_length\":10,\"should_delete\":false,\"should_save\":false,\"ignore_emoji\":true,\"threshold\":80}' Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/settings"},{"location":"md/web/#put-apispamsetminlenmin_length","text":"set min length of message that should be checked for spam. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"PUT /api/spam/set/minlen/&lt;min_length&gt;"},{"location":"md/web/#put-apispamsetmaxlenmin_length","text":"set max length of message that should be checked for spam. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"PUT /api/spam/set/maxlen/&lt;min_length&gt;"},{"location":"md/web/#post-apispamdisablesave","text":"Disable saving of spam messages to separate 'spams' table. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/disable/save"},{"location":"md/web/#post-apispamdisabledelete","text":"Disable deletion of spam messages from storage backend. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/disable/delete"},{"location":"md/web/#post-apispamenablesave","text":"Enable saving of spam messages to separate 'spams' table. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/enable/save"},{"location":"md/web/#post-apispamenabledelete","text":"Enable deletion of spam messages from storage backend. Response: { \"data\": {}, \"message\": \"\", \"status_code\": 200 }","title":"POST /api/spam/enable/delete"},{"location":"md/web/#deleting-a-message-classified-as-spam","text":"The message_id field describes the ID of the message stored in the message store. It can be deleted by using the history web API: user@box:~$ curl -X GET localhost:4556/api/spam/3 { \"data\": { \"correct\": true, \"from_id\": \"115584\", \"from_name\": \"\", \"id\": 3, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": false, \"message_id\": \"21aa49f3-3dc5-4bef-a08d-84f7a516bf49\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535309860, \"to_id\": \"115584\", \"to_name\": \"jkvkjvh\" }, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X DELETE localhost:4556/api/history/21aa49f3-3dc5-4bef-a08d-84f7a516bf49 { \"data\": {}, \"message\": \"\", \"status_code\": 200 } user@box:~$ curl -X GET localhost:4556/api/spam/3 { \"data\": { \"correct\": true, \"from_id\": \"115584\", \"from_name\": \"\", \"id\": 3, \"message\": \"\\ud835\\udd4e\\ud835\\udd3c\\ud835\\udd4e\\ud835\\udd5a\\ud835\\udd43\\ud835\\udd43\\ud835\\udd4a\\ud835\\udd4b\\ud835\\udd3b\\ud835\\udd4c\", \"message_deleted\": true, \"message_id\": \"21aa49f3-3dc5-4bef-a08d-84f7a516bf49\", \"object_type\": \"room\", \"probability\": \"0.932408,0.98,1\", \"time_stamp\": 1535309860, \"to_id\": \"115584\", \"to_name\": \"jkvkjvh\" }, \"message\": \"\", \"status_code\": 200 }","title":"Deleting a message classified as spam"},{"location":"md/web/#probability","text":"The field probability are percentages from three different classifiers. If at least two of them predict with a percentage of at least 66% that a message is spam, then it will be labeled as such. The first number is from XGBoost, the second from a Random Forest, and the third SVC with a polynomial kernel. The third number is always either 0 or 1 , and never a fraction.","title":"Probability"},{"location":"md/wio/","text":"Online status is kept in redis for users who successfully logs in and keeps their socket connection open. Four keys are maintained in redis: users:online:bitmap users:online:set users:online:inrooms users:multicast user:status:USER_ID user:online:last:USER_ID users:online:bitmap (BITMAP) The ID of the user is used as the offset in the bitmap. When a user logs in the bit in that offset will be set to 1, and when the user's socket closes the bit is set to 0. users:online:set (SET) A set containing all the IDs of users who are currently online. When a user logs in the user ID is added to the set, and when the socket closes the ID is removed from the set. When a user changes his/her status to invisible his/her ID will also be removed from this set. users:multicast (SET) Same as users:online:set , except that when a user goes invisible the user ID stays in this set. This allows multicasting of notifications without showing up as online . user:status:USER_ID (STRING) One key for each user containing the status, which is a single character with the following meaning: 1: available (online) 2: chatting (not currently used) 3: invisible 4: unavailable (offline) 5: unknown users:online:inrooms (STRING) A count of the number of online users who are in rooms. The other online keys includes users who are online but haven't joined any rooms, this key does not. Not updated in real-time, but on a regular interval by a cron job. user:online:last:USER_ID (STRING) A timestamp when the user last went offline. If a user logs in as invisible then logs out as invisible, the timestamp is NOT changed. If a user is visible and turns invisible, then logs out, the timestamp is set to the time the user went invisible, not when the user logged out.","title":"Who Is Online?"},{"location":"md/wio/#usersonlinebitmap-bitmap","text":"The ID of the user is used as the offset in the bitmap. When a user logs in the bit in that offset will be set to 1, and when the user's socket closes the bit is set to 0.","title":"users:online:bitmap (BITMAP)"},{"location":"md/wio/#usersonlineset-set","text":"A set containing all the IDs of users who are currently online. When a user logs in the user ID is added to the set, and when the socket closes the ID is removed from the set. When a user changes his/her status to invisible his/her ID will also be removed from this set.","title":"users:online:set (SET)"},{"location":"md/wio/#usersmulticast-set","text":"Same as users:online:set , except that when a user goes invisible the user ID stays in this set. This allows multicasting of notifications without showing up as online .","title":"users:multicast (SET)"},{"location":"md/wio/#userstatususer_id-string","text":"One key for each user containing the status, which is a single character with the following meaning: 1: available (online) 2: chatting (not currently used) 3: invisible 4: unavailable (offline) 5: unknown","title":"user:status:USER_ID (STRING)"},{"location":"md/wio/#usersonlineinrooms-string","text":"A count of the number of online users who are in rooms. The other online keys includes users who are online but haven't joined any rooms, this key does not. Not updated in real-time, but on a regular interval by a cron job.","title":"users:online:inrooms (STRING)"},{"location":"md/wio/#useronlinelastuser_id-string","text":"A timestamp when the user last went offline. If a user logs in as invisible then logs out as invisible, the timestamp is NOT changed. If a user is visible and turns invisible, then logs out, the timestamp is set to the time the user went invisible, not when the user logged out.","title":"user:online:last:USER_ID (STRING)"}]}